Curve-based video multiview reconstruction design specifications
================================================================

Guidelines:
  - Make the system as modular as possible.

Input: 
  - Video sequence
  - Cameras
  - Edges and curve fragments from files. A separate program's task is to
    compute them. Think of Bundler's architecture: a core program that just does
    the SFM, but with features computed by an external program (Lowe's sift).
    - Save edges and curves with a very low gradient threshold and no pruning by
      length, so that generating ROC in terms of these parameters is cheap.

Output:
  - 3D reconstruction curves and their tangents.  Format?
  - New cameras. Format? Easiest. intrinsic/extrinsic is fine.
  - Future:
    - Better edges
    - Edge labeling
    - Surface patches for the occluding contours
    - Correspondence datastructure for each 2 views

Pseudocode:
  - Load data parameters
    - File names, how many views
  - Load system parameters.
  - Initialize 2-view matcher with suitable parameters
  - For each 2 views and a set of confirmation views given by a view selection subclass
    - Ask for the data from the repository, which will load, recompute, or read
      from cache, as needed.
    - Match and reconstruct using orientation
      - Append 3D curves to a global 3D reconstruction datastructure
  - Output the global 3D curves structure 

Memory requirements
  - Impossible to load all ~500 edge maps in memory.
  - We need to stream the data. At each pairwise time, we ask for the suitable
    data from the repository. If it is not in memory, load it. Destroy the least
    recent map.
  - Caching scheme also works for other things: we should not recompute distance
    maps if they are already computed. So the driver for the 2-view stereo
    matcher asks the repository if a distance map for view[v] is in memory. If
    so, it uses that. If not, it recomputes it.

Parameters of the system:
  - Edge gradient threshold
  - Curve fragment length threshold
  - Note: the parameters for the edge detector and edge linker that can only be
    set upon detection can't be controlled by this application. 
  - Future: other curve fragment thresholds, such as average length
  - Basic symbolic linker parameters - useful in vox.
  - Reprojection threshold for distance
  - Reprojection threshold for tangents
  - Type of matching algorithm
    - because we want to show in the ROC's that tangent is really better than
      position.
  - The interpolation strategy (GENO or from Amir's. We want to compare these).
  - How much smoothing of the curve fragments
  - The baseline to be used in view selection for pairwise matching
    - Can be specified in number of frames to skip.
    - We can also have placeholder code for
      other strategies such as: user defined sequence; or 
      two views that satisfy some criteria dependent on
      the distance between the camera center, or even we can pick a set of n
      views within the set of views that as equally spaced as possible. We can
      also determine the minimum baseline automatically:
        - assuming a (pessimistic) 1px edge and tangent localization error as
          read from the edgemap
        - assuming a camera calibration error specified by the user or through
          the reprojection erro of the calibration phase.
        - given minimum desired 3D acuracy
        - a routine computes what is the necessary baseline to achieve the
          accuracy
  - How many confirmation views. Can have multiple strategies:
      - Give only a number of confirmation views, and a view-selection class
        picks them
      - Provide an explicit list of confirmation views for each 2 views.

  - Bucket size, if we use 3D bucketing.
    - The ROC curve for bucketing size will allow us to set an optimum bucket
      size for a given dataset. By doing this ROC for a couple of different
      datasets, we infer what the optimum default value should be.

  - Design choice: do the same design as mw_stereo_app, so that another C++
    class can also run the system almost as if it was command line.

TODO:
  * Make stereo system independent of which 2 views are being matched. Right now
    it is 0 and 1.

  - Representation for the 3D curves
    - What file representation?
      - Should have the view id so that I can plot in matlab with different
        colors.
    - What memory representation?
      - Should we store metadata in the 3D curves?
        - id of views it came from, id of curve fragments it came from
        - edge consensus set, i.e., what are the inlier views and, within those
          views, what are the inlier edgels.
  
  * Program to just compute the edges and curve fragments for each image. Try to
    mimick Lowe's sift interface
      - Input: One image file
      - Output: Curve fragment file plus edge map file
        - Future: Binary file with Amir's SEL.
      - A static binary can be made available, just like sift.

  - Synthetic data so that we have an automated regression test
  - Ground-truth matches in real data. Vox.
  - Study Matt's architecture for processes (basic/dbpro). Study how can we stream the data without
    having to use breye2.

REDUCED VERSION OF THE SYSTEM 

Goal: 
  - The above system should work by specifying just 2 views.
  - We can generate ROC curves in vox.

  - We can write a simple Matlab driver that:

    1- runs the algorithm for a pair of views
    2- collects the output reconstruction
    3- repeats 1 and 2 to put the 3D curves together.

  - Such a simple application will allow us to:
    - generate ROC curves by varying the numerous parameters
    - study how many views we typically need

  - We can, thus, code the system with the goal of getting this first.

(c) Ricardo Fabbri
Mon Aug 24 22:18:18 EDT 2009
