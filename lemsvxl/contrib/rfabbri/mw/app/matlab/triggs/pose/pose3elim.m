% Basic elimination subroutine for calibrated camera pose from 3 known
% 3D points. Also used by 4 point methods.
%
% For each pair of input points we have a cosine rule constraint
%
%	Pij(ui,uj) = ui^2+uj^2-2*cos(theta_ij)*ui*uj - dij^2 = 0
%
% where ui,uj are the camera-point distances, dij the distance between
% the corresponding 3D points, and theta_ij the angle between the
% direction vectors from the camera to the 3D points, as measured by the
% calibrated camera. For convenience we define 
%
%	Cij = 2*cos(theta_ij) and Dij = dij^2
%
% Given P12,P13,P23, we eliminate u2 and u3 to get a polynomial in u1^2,
% which we can later solve to get u1 and hence the pose. This routine
% returns the polynomial in the form 
%
%	R(u1^2) = R * [1; u1^2; u1^4; u1^6; u1^8].
%
% Note that the output polynomial has only even terms, as if (u1,u2,u3)
% is a solution to the input system, then so is (-u1,-u2,-u3). Of course
% we take only the positive solution when solving.
%
% The code below was generated by Maple eliminate() and fortran(). For
% convenience, we first changed variables to
%
%	y1 = 1/u1^2, y2 = u2/u1, y3 = u3/u1
%
% to get the system 
%
%	P12' =  1   + y2^2 - C12*y2    - D12*y1 = 0
%	P13' =  1   + y3^2 - C13*y3    - D13*y1 = 0
%	P23' = y2^2 + y3^2 - C23*y2*y3 - D23*y1 = 0
%
% Eliminate y3 between P13' and P23' to get a polynomial 
%
%  Q(y1,y2) = Q * [y2^4; y1*y2^2; y2^3; y1^2; y1*y2; y2^2; y1; y2; 1].
%
% Then eliminate y2 between Q and P12' to get the output 
%
%	R(y1) = R * [y1^4; y1^3; y1^2; y1; 1]
%
% If called with a 7th argument y1 = u1^-2, the routine doesn't
% calculate R, but instead back substitutes to find [u1,u2,u3] using 
% formulae (which may not be ideal) found by Maple eliminate().

function R = pose3elim(C12,D12, C13,D13, C23,D23, y1)

   % Eliminate y3 between P13' and P23' to get Q(y1,y2) 
   % q1 = 1;
   q2 = (2-C23^2)*D13-2*D23;
   q3 = -C13*C23;
   q4 = (D13-D23)^2;
   q5 = C23*C13*(D13+D23);
   q6 = C13^2+C23^2-2;
   q7 = (2-C13^2)*D23-2*D13;
   q8 = -C13*C23;
   % q9 = 1;
   
   % Now eliminate y2 between P12' and Q to get R(y1)

   d = D12; 
   c = C12;
   d2 = d^2;
   d3 = d2*d;
   c2 = c^2;
   c3 = c2*c;
   c4 = c2^2;
   if nargin>=7
      % Backsubstitute for solution rather than returning 
      % resultant polynomial.
      if y1<=0
	 % Invalid complex solution
	 R = [];
      else
	 y2 = -((d*q2+d2+q4)*y1^2+(d*(c2+c*q3-2+q6)+q7-q2)*y1...
	          +2-c*q3-c2-q6) ...
	       /((q5+d*q3+c*(q2+2*d))*y1+c*(q6-2+c*q3+c2)-q3+q8);
	 y3 = ((D13-D23)*y1+y2^2-1)/(C23*y2-C13);
	 R = [1,y2,y3]/sqrt(y1);
      end
      return;
   end;

   q22 = q2^2;
   q23 = q2*q3;
   q24 = q2*q4;
   q26 = q2*q6;
   q27 = q2*q7;
   q28 = q2*q8;
   q33 = q3^2;
   q34 = q3*q4;
   q35 = q3*q5;
   q36 = q3*q6;
   q37 = q3*q7;
   q38 = q3*q8;
   q46 = q4*q6;
   q55 = q5^2;
   q56 = q5*q6;
   q58 = q5*q8;
   q66 = q6^2;
   q67 = q6*q7;
   q88 = q8^2;
   R = [ (d2^2+2*d3*q2+(2*q4+q22)*d2+2*d*q24+q4^2), ...
	  ((-c*q3-q33+2*q6-4)*d3 ...
	    +(q2*c2+(-3*q5+q23)*c-6*q2+2*q26-2*q35+2*q7)*d2 ...
	    +(4*q4*c2+(-q2*q5+3*q34)*c-q55+2*q46+2*q27-2*q22-4*q4)*d ...
	    +q4*(q2*c2+q5*c-2*(q2-q7))), ...
	  ((c2*q6+(-3*q8+3*q3+q36)*c+q66-6*q6 ...
	    -2*q38+3*q33+8)*d2+(-q5*c3+(-2*q2+4*q7-q35)*c2 ...
	    +(-q28-2*q23+3*q37-q56+6*q5)*c+8*q2-2*q58-4*q7 ...
	    +2*q67-4*q26+4*q35)*d+q4*c4+q34*c3 ...
	    +(q46+q27-4*q4)*c2+(-3*q34+q2*q5+q7*q5+q4*q8)*c ...
	    +q22+q55+4*q4-2*q46-2*q27+q7^2), ...
	  ((-c3*q8+(-q38+4-2*q6)*c2+(-2*q36+6*q8-q8*q6)*c ...
	    +8*q6-q88-8-2*q66+4*q38-3*q33)*d+q7*c4 ...
	    +(q37+q5)*c3+(q35+2*q2-4*q7+q67)*c2 ...
	    +(q56-2*q5+q7*q8-3*q37+q28+q23)*c-4*q2 ...
	    +2*q26+4*q7-2*q67+2*q58-2*q35), ...
	  (c4+(q38+2*q6-4)*c2+(q6-2+c2)*(q3+q8)*c ...
	    +4-4*q6+q88-2*q38+q66+q33) ];

%end;
