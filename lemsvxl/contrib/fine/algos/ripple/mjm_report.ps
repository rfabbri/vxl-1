%!PS-Adobe-3.0
%%BoundingBox: (atend)
%%Pages: (atend)
%%PageOrder: (atend)
%%DocumentFonts: (atend)
%%Creator: Frame 5.0
%%DocumentData: Clean7Bit
%%EndComments
%%BeginProlog
%
% Frame ps_prolog 5.0, for use with Frame 5.0 products
% This ps_prolog file is Copyright (c) 1986-1995 Frame Technology
% Corporation.  All rights reserved.  This ps_prolog file may be
% freely copied and distributed in conjunction with documents created
% using FrameMaker, FrameMaker/SGML and FrameViewer as long as this 
% copyright notice is preserved.
%
% FrameMaker users specify the proper paper size for each print job in the
% "Print" dialog's "Printer Paper Size" "Width" and "Height~ fields.  If the
% printer that the PS file is sent to does not support the requested paper
% size, or if there is no paper tray of the proper size currently installed, 
% then the job will not be printed.  The following flag, if set to true, will
% cause the job to print on the default paper in such cases.
/FMAllowPaperSizeMismatch            false def
%
% Frame products normally print colors as their true color on a color printer
% or as shades of gray, based on luminance, on a black-and white printer. The
% following flag, if set to true, forces all non-white colors to print as pure
% black. This has no effect on bitmap images.
/FMPrintAllColorsAsBlack             false def
%
% Frame products can either set their own line screens or use a printer's 
% default settings. Three flags below control this separately for no 
% separations, spot separations and process separations. If a flag
% is true, then the default printer settings will not be changed. If it is
% false, Frame products will use their own settings from a table based on
% the printer's resolution.
/FMUseDefaultNoSeparationScreen      true  def
/FMUseDefaultSpotSeparationScreen    true  def
/FMUseDefaultProcessSeparationScreen false def
%
% For any given PostScript printer resolution, Frame products have two sets of 
% screen angles and frequencies for printing process separations, which are 
% recomended by Adobe. The following variable chooses the higher frequencies
% when set to true or the lower frequencies when set to false. This is only
% effective if the appropriate FMUseDefault...SeparationScreen flag is false.
/FMUseHighFrequencyScreens true def
%
% The following is a set of predefined optimal frequencies and angles for various
% common dpi settings. This is taken from "Advances in Color Separation Using
% PostScript Software Technology," from Adobe Systems (3/13/89 P.N. LPS 0043)
% and corrolated with information which is in various PPD (4.0) files.
%
% The "dpiranges" figure is the minimum dots per inch device resolution which
% can support this setting. The "low" and "high" values are controlled by the
% setting of the FMUseHighFrequencyScreens flag above. The "TDot" flags control
% the use of the "Yellow Triple Dot" feature whereby the frequency id divided by
% three, but the dot function is "trippled" giving a block of 3x3 dots per cell.
%
% PatFreq is a compromise pattern frequency for ps Level 2 printers which is close
% to the ideal WYSIWYG pattern frequency of 9 repetitions/inch but does not beat
% (too badly) against the screen frequencies of any separations for that DPI.
/dpiranges   [  2540    2400    1693     1270    1200     635      600      0      ] def
/CMLowFreqs  [ 100.402  94.8683 89.2289 100.402  94.8683  66.9349  63.2456 47.4342 ] def
/YLowFreqs   [  95.25   90.0    84.65    95.25   90.0     70.5556  66.6667 50.0    ] def
/KLowFreqs   [  89.8026 84.8528 79.8088  89.8026 84.8528  74.8355  70.7107 53.033  ] def
/CLowAngles  [  71.5651 71.5651 71.5651 71.5651  71.5651  71.5651  71.5651 71.5651 ] def
/MLowAngles  [  18.4349 18.4349 18.4349 18.4349  18.4349  18.4349  18.4349 18.4349 ] def
/YLowTDot    [  true    true    false    true    true     false    false   false   ] def
/CMHighFreqs [ 133.87  126.491 133.843  108.503 102.523  100.402   94.8683 63.2456 ] def
/YHighFreqs  [ 127.0   120.0   126.975  115.455 109.091   95.25    90.0    60.0    ] def
/KHighFreqs  [ 119.737 113.137 119.713  128.289 121.218   89.8026  84.8528 63.6395 ] def
/CHighAngles [  71.5651 71.5651 71.5651  70.0169 70.0169  71.5651  71.5651 71.5651 ] def
/MHighAngles [  18.4349 18.4349 18.4349  19.9831 19.9831  18.4349  18.4349 18.4349 ] def
/YHighTDot   [  false   false   true     false   false    true     true    false   ] def
/PatFreq     [    10.5833 10.0     9.4055  10.5833 10.0      10.5833  10.0       9.375   ] def
%
% PostScript Level 2 printers contain an "Accurate Screens" feature which can
% improve process separation rendering at the expense of compute time. This 
% flag is ignored by PostScript Level 1 printers.
/FMUseAcccurateScreens true def
%
% The following PostScript procedure defines the spot function that Frame
% products will use for process separations. You may un-comment-out one of
% the alternative functions below, or use your own.
%
% Dot function
/FMSpotFunction {abs exch abs 2 copy add 1 gt 
        {1 sub dup mul exch 1 sub dup mul add 1 sub }
        {dup mul exch dup mul add 1 exch sub }ifelse } def
%
% Line function
% /FMSpotFunction { pop } def
%
% Elipse function
% /FMSpotFunction { dup 5 mul 8 div mul exch dup mul exch add 
%        sqrt 1 exch sub } def
%
%
/FMversion (5.0) def 
/fMLevel1 /languagelevel where {pop languagelevel} {1} ifelse 2 lt def
/FMPColor
    fMLevel1 {
        false
        /colorimage where {pop pop true} if
    } {
        true
    } ifelse
def
/FrameDict 400 dict def 
systemdict /errordict known not {/errordict 10 dict def
        errordict /rangecheck {stop} put} if
% The readline in PS 23.0 doesn't recognize cr's as nl's on AppleTalk
FrameDict /tmprangecheck errordict /rangecheck get put 
errordict /rangecheck {FrameDict /bug true put} put 
FrameDict /bug false put 
mark 
% Some PS machines read past the CR, so keep the following 3 lines together!
currentfile 5 string readline
00
0000000000
cleartomark 
errordict /rangecheck FrameDict /tmprangecheck get put 
FrameDict /bug get { 
    /readline {
        /gstring exch def
        /gfile exch def
        /gindex 0 def
        {
            gfile read pop 
            dup 10 eq {exit} if 
            dup 13 eq {exit} if 
            gstring exch gindex exch put 
            /gindex gindex 1 add def 
        } loop
        pop 
        gstring 0 gindex getinterval true 
        } bind def
    } if
/FMshowpage /showpage load def
/FMquit /quit load def
/FMFAILURE { 
    dup = flush 
    FMshowpage 
    /Helvetica findfont 12 scalefont setfont
    72 200 moveto show
    72 220 moveto show
    FMshowpage 
    FMquit 
    } def 
/FMVERSION {
    FMversion ne {
        (Frame product version does not match ps_prolog!  Check installation;)
        (also check ~/fminit and ./fminit for old versions) FMFAILURE
        } if
    } def 
/FMBADEPSF { 
    (Adobe's PostScript Language Reference Manual, 2nd Edition, section H.2.4)
    (says your EPS file is not valid, as it calls X              )
    dup dup (X) search pop exch pop exch pop length 
    5 -1 roll 
    putinterval 
    FMFAILURE
    } def
/fmConcatProcs
    {
    /proc2 exch cvlit def/proc1 exch cvlit def/newproc proc1 length proc2 length add array def
    newproc 0 proc1 putinterval newproc proc1 length proc2 putinterval newproc cvx
}def
FrameDict begin [
    /ALDsave
    /FMdicttop
    /FMoptop
    /FMpointsize
    /FMsaveobject
    /b
    /bitmapsave
    /blut
    /bpside
    /bs
    /bstring
    /bwidth
    /c
    /cf
    /cs
    /cynu
    /depth
    /edown
    /fh
    /fillvals
    /fw
    /fx
    /fy
    /g
    /gfile
    /gindex
    /grnt
    /gryt
    /gstring
    /height
    /hh
    /i
    /im
    /indx
    /is
    /k
    /kk
    /landscape
    /lb
    /len
    /llx
    /lly
    /m
    /magu
    /manualfeed
    /n
    /offbits
    /onbits
    /organgle
    /orgbangle
    /orgbfreq
    /orgbproc
    /orgbxfer
    /orgfreq
    /orggangle
    /orggfreq
    /orggproc
    /orggxfer
    /orgmatrix
    /orgproc
    /orgrangle
    /orgrfreq
    /orgrproc
    /orgrxfer
    /orgxfer
    /pagesave
    /paperheight
    /papersizedict
    /paperwidth
    /pos
    /pwid
    /r
    /rad
    /redt
    /sl
    /str
    /tran
    /u
    /urx
    /ury
    /val
    /width
    /width
    /ws
    /ww
    /x
    /x1
    /x2
    /xindex
    /xpoint
    /xscale
    /xx
    /y
    /y1
    /y2
    /yelu
    /yindex
    /ypoint
    /yscale
    /yy
] { 0 def } forall
/FmBD {bind def} bind def
systemdict /pdfmark known {
    /fMAcrobat true def
    
    /FmPD /pdfmark load def
    
    
    /FmPT /show load def
    
    
    currentdistillerparams /CoreDistVersion get 2000 ge {
    
        
        /FmPD2 /pdfmark load def
        
        
        
        
        
        /FmPA { mark exch /Dest exch 5 3 roll 
                /View [ /XYZ null 6 -2 roll FmDC exch pop null] /DEST FmPD 
        }FmBD
    } {
        
        /FmPD2 /cleartomark load def
        /FmPA {pop pop pop}FmBD
    } ifelse
} {
    
    /fMAcrobat false def
    /FmPD /cleartomark load def
    /FmPD2 /cleartomark load def
    /FmPT /pop load def
    /FmPA {pop pop pop}FmBD
} ifelse
/FmDC {
    transform fMDefaultMatrix itransform cvi exch cvi exch
}FmBD
/FmBx {
    dup 3 index lt {3 1 roll exch} if 
    1 index 4 index lt {4 -1 roll 3 1 roll exch 4 1 roll} if
}FmBD
/FMnone 0 def
/FMcyan 1 def
/FMmagenta 2 def
/FMyellow 3 def
/FMblack 4 def
/FMcustom 5 def
/fMNegative false def 
/FrameSepIs FMnone def 
/FrameSepBlack 0 def
/FrameSepYellow 0 def
/FrameSepMagenta 0 def
/FrameSepCyan 0 def
/FrameSepRed 1 def
/FrameSepGreen 1 def
/FrameSepBlue 1 def
/FrameCurGray 1 def
/FrameCurPat null def
/FrameCurColors [ 0 0 0 1 0 0 0 ] def 
/FrameColorEpsilon .001 def    
/eqepsilon {        
    sub dup 0 lt {neg} if
    FrameColorEpsilon le
} bind def
/FrameCmpColorsCMYK { 
    2 copy 0 get exch 0 get eqepsilon {
        2 copy 1 get exch 1 get eqepsilon {
            2 copy 2 get exch 2 get eqepsilon {
                3 get exch 3 get eqepsilon
            } {pop pop false} ifelse
        }{pop pop false} ifelse
    } {pop pop false} ifelse
} bind def
/FrameCmpColorsRGB { 
    2 copy 4 get exch 0 get eqepsilon {
        2 copy 5 get exch 1 get eqepsilon {
            6 get exch 2 get eqepsilon
        }{pop pop false} ifelse
    } {pop pop false} ifelse
} bind def
/RGBtoCMYK { 
    1 exch sub 
    3 1 roll 
    1 exch sub 
    3 1 roll 
    1 exch sub 
    3 1 roll 
    3 copy 
    2 copy 
    le { pop } { exch pop } ifelse 
    2 copy 
    le { pop } { exch pop } ifelse 
    dup dup dup 
    6 1 roll 
    4 1 roll 
    7 1 roll 
    sub 
    6 1 roll 
    sub 
    5 1 roll 
    sub 
    4 1 roll 
} bind def
/CMYKtoRGB { 
    dup dup 4 -1 roll add                           
    5 1 roll 3 -1 roll add                           
    4 1 roll add                                   
    1 exch sub dup 0 lt {pop 0} if 3 1 roll       
    1 exch sub dup 0 lt {pop 0} if exch           
    1 exch sub dup 0 lt {pop 0} if exch                
} bind def
/FrameSepInit {
    1.0 RealSetgray
} bind def
/FrameSetSepColor { 
    /FrameSepBlue exch def
    /FrameSepGreen exch def
    /FrameSepRed exch def
    /FrameSepBlack exch def
    /FrameSepYellow exch def
    /FrameSepMagenta exch def
    /FrameSepCyan exch def
    /FrameSepIs FMcustom def
    setCurrentScreen    
} bind def
/FrameSetCyan {
    /FrameSepBlue 1.0 def
    /FrameSepGreen 1.0 def
    /FrameSepRed 0.0 def
    /FrameSepBlack 0.0 def
    /FrameSepYellow 0.0 def
    /FrameSepMagenta 0.0 def
    /FrameSepCyan 1.0 def
    /FrameSepIs FMcyan def
    setCurrentScreen    
} bind def
 
/FrameSetMagenta {
    /FrameSepBlue 1.0 def
    /FrameSepGreen 0.0 def
    /FrameSepRed 1.0 def
    /FrameSepBlack 0.0 def
    /FrameSepYellow 0.0 def
    /FrameSepMagenta 1.0 def
    /FrameSepCyan 0.0 def
    /FrameSepIs FMmagenta def
    setCurrentScreen
} bind def
 
/FrameSetYellow {
    /FrameSepBlue 0.0 def
    /FrameSepGreen 1.0 def
    /FrameSepRed 1.0 def
    /FrameSepBlack 0.0 def
    /FrameSepYellow 1.0 def
    /FrameSepMagenta 0.0 def
    /FrameSepCyan 0.0 def
    /FrameSepIs FMyellow def
    setCurrentScreen
} bind def
 
/FrameSetBlack {
    /FrameSepBlue 0.0 def
    /FrameSepGreen 0.0 def
    /FrameSepRed 0.0 def
    /FrameSepBlack 1.0 def
    /FrameSepYellow 0.0 def
    /FrameSepMagenta 0.0 def
    /FrameSepCyan 0.0 def
    /FrameSepIs FMblack def
    setCurrentScreen
} bind def
 
/FrameNoSep { 
    /FrameSepIs FMnone def
    setCurrentScreen
} bind def
/FrameSetSepColors { 
    FrameDict begin
    [ exch 1 add 1 roll ]
    /FrameSepColors  
    exch def end
    } bind def
/FrameColorInSepListCMYK { 
    FrameSepColors {  
               exch dup 3 -1 roll 
               FrameCmpColorsCMYK 
               { pop true exit } if
        } forall 
    dup true ne {pop false} if
    } bind def
/FrameColorInSepListRGB { 
    FrameSepColors {  
               exch dup 3 -1 roll 
               FrameCmpColorsRGB 
               { pop true exit } if
        } forall 
    dup true ne {pop false} if
    } bind def
/RealSetgray /setgray load def
/RealSetrgbcolor /setrgbcolor load def
/RealSethsbcolor /sethsbcolor load def
end 
/setgray { 
    FrameDict begin
    FrameSepIs FMnone eq
        { RealSetgray } 
        { 
        FrameSepIs FMblack eq 
            { RealSetgray } 
            { FrameSepIs FMcustom eq 
              FrameSepRed 0 eq and
              FrameSepGreen 0 eq and
              FrameSepBlue 0 eq and {
                  RealSetgray
              } {
                1 RealSetgray pop 
              } ifelse
            } ifelse
        } ifelse
    end
} bind def
/setrgbcolor { 
    FrameDict begin
    FrameSepIs FMnone eq
    {  RealSetrgbcolor }
    {
        3 copy [ 4 1 roll ] 
        FrameColorInSepListRGB
        {
                FrameSepBlue eq exch 
                 FrameSepGreen eq and exch 
                 FrameSepRed eq and
                 { 0 } { 1 } ifelse
        }
        {
            FMPColor {
                RealSetrgbcolor
                currentcmykcolor
            } {
                RGBtoCMYK
            } ifelse
            FrameSepIs FMblack eq
            {1.0 exch sub 4 1 roll pop pop pop} {
            FrameSepIs FMyellow eq
            {pop 1.0 exch sub 3 1 roll pop pop} {
            FrameSepIs FMmagenta eq
            {pop pop 1.0 exch sub exch pop } {
            FrameSepIs FMcyan eq
            {pop pop pop 1.0 exch sub } 
            {pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
        } ifelse
        RealSetgray
    } 
    ifelse
    end
} bind def
/sethsbcolor {
    FrameDict begin
    FrameSepIs FMnone eq 
    { RealSethsbcolor } 
    {
        RealSethsbcolor 
        currentrgbcolor  
        setrgbcolor 
    } 
    ifelse
    end
} bind def
FrameDict begin
/setcmykcolor where {
    pop /RealSetcmykcolor /setcmykcolor load def
} {
    /RealSetcmykcolor {
        4 1 roll
        3 { 3 index add 0 max 1 min 1 exch sub 3 1 roll} repeat 
        RealSetrgbcolor pop
    } bind def
} ifelse
userdict /setcmykcolor { 
        FrameDict begin
        FrameSepIs FMnone eq
        { RealSetcmykcolor } 
        {
            4 copy [ 5 1 roll ]
            FrameColorInSepListCMYK
            {
                FrameSepBlack eq exch 
                FrameSepYellow eq and exch 
                FrameSepMagenta eq and exch 
                FrameSepCyan eq and 
                { 0 } { 1 } ifelse
            }
            {
                FrameSepIs FMblack eq
                {1.0 exch sub 4 1 roll pop pop pop} {
                FrameSepIs FMyellow eq
                {pop 1.0 exch sub 3 1 roll pop pop} {
                FrameSepIs FMmagenta eq
                {pop pop 1.0 exch sub exch pop } {
                FrameSepIs FMcyan eq
                {pop pop pop 1.0 exch sub } 
                {pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
            } ifelse
            RealSetgray
        }
        ifelse
        end
    } bind put
fMLevel1 { 
    
    
    
    /patScreenDict 7 dict dup begin
        <0f1e3c78f0e1c387> [ 45  { pop } {exch pop}         .5   2 sqrt] FmBD
        <0f87c3e1f0783c1e> [ 135 { pop } {exch pop}            .5   2 sqrt] FmBD
        <cccccccccccccccc> [ 0   { pop } dup                .5   2       ] FmBD
        <ffff0000ffff0000> [ 90  { pop } dup                .5   2       ] FmBD
        <8142241818244281> [ 45  { 2 copy lt {exch} if pop}    dup .75  2 sqrt] FmBD
        <03060c183060c081> [ 45  { pop } {exch pop}            .875 2 sqrt] FmBD
        <8040201008040201> [ 135 { pop } {exch pop}            .875 2 sqrt] FmBD
    end def
} { 
    
    /patProcDict 5 dict dup begin
        <0f1e3c78f0e1c387> { 3 setlinewidth -1 -1 moveto 9 9 lineto stroke 
                                            4 -4 moveto 12 4 lineto stroke
                                            -4 4 moveto 4 12 lineto stroke} bind def
        <0f87c3e1f0783c1e> { 3 setlinewidth -1 9 moveto 9 -1 lineto stroke 
                                            -4 4 moveto 4 -4 lineto stroke
                                            4 12 moveto 12 4 lineto stroke} bind def
        <8142241818244281> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke
                                            -1 -1 moveto 9 9 lineto stroke } bind def
        <03060c183060c081> { 1 setlinewidth -1 -1 moveto 9 9 lineto stroke 
                                            4 -4 moveto 12 4 lineto stroke
                                            -4 4 moveto 4 12 lineto stroke} bind def
        <8040201008040201> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke 
                                            -4 4 moveto 4 -4 lineto stroke
                                            4 12 moveto 12 4 lineto stroke} bind def
    end def
    /patDict 15 dict dup begin
        /PatternType 1 def        
        /PaintType 2 def        
        /TilingType 3 def        
        /BBox [ 0 0 8 8 ] def     
        /XStep 8 def            
        /YStep 8 def            
        /PaintProc {
            begin
            patProcDict bstring known {
                patProcDict bstring get exec
            } {
                8 8 true [1 0 0 -1 0 8] bstring imagemask
            } ifelse
            end
        } bind def
    end def
} ifelse
/combineColor {
    FrameSepIs FMnone eq
    {
        graymode fMLevel1 or not {
            
            [/Pattern [/DeviceCMYK]] setcolorspace
            FrameCurColors 0 4 getinterval aload pop FrameCurPat setcolor
        } {
            FrameCurColors 3 get 1.0 ge {
                FrameCurGray RealSetgray
            } {
                fMAcrobat not FMPColor graymode and and {
                    0 1 3 { 
                        FrameCurColors exch get
                        1 FrameCurGray sub mul
                    } for
                    RealSetcmykcolor
                } {
                    4 1 6 {
                        FrameCurColors exch get
                        graymode {
                            1 exch sub 1 FrameCurGray sub mul 1 exch sub
                        } {
                            1.0 lt {FrameCurGray} {1} ifelse
                        } ifelse
                    } for
                    RealSetrgbcolor
                } ifelse
            } ifelse
        } ifelse
    } { 
        FrameCurColors 0 4 getinterval aload
        FrameColorInSepListCMYK {
            FrameSepBlack eq exch 
            FrameSepYellow eq and exch 
            FrameSepMagenta eq and exch 
            FrameSepCyan eq and
            FrameSepIs FMcustom eq and
            { FrameCurGray } { 1 } ifelse
        } {
            FrameSepIs FMblack eq
            {FrameCurGray 1.0 exch sub mul 1.0 exch sub 4 1 roll pop pop pop} {
            FrameSepIs FMyellow eq
            {pop FrameCurGray 1.0 exch sub mul 1.0 exch sub 3 1 roll pop pop} {
            FrameSepIs FMmagenta eq
            {pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub exch pop } {
            FrameSepIs FMcyan eq
            {pop pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub } 
            {pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
        } ifelse
        graymode fMLevel1 or not {
            
            [/Pattern [/DeviceGray]] setcolorspace
            FrameCurPat setcolor
        } { 
            graymode not fMLevel1 and {
                
                dup 1 lt {pop FrameCurGray} if
            } if
            RealSetgray
        } ifelse
    } ifelse
} bind def
/savematrix {
    orgmatrix currentmatrix pop
    } bind def
/restorematrix {
    orgmatrix setmatrix
    } bind def
/fMDefaultMatrix matrix defaultmatrix def
/fMatrix2 matrix def
/dpi    72 0 fMDefaultMatrix dtransform
    dup mul exch   dup mul add   sqrt def
    
/freq dpi dup 72 div round dup 0 eq {pop 1} if 8 mul div def
/sangle 1 0 fMDefaultMatrix dtransform exch atan def
    sangle fMatrix2 rotate 
    fMDefaultMatrix fMatrix2 concatmatrix 
    dup 0 get /sflipx exch def
        3 get /sflipy exch def
/screenIndex {
    0 1 dpiranges length 1 sub { dup dpiranges exch get 1 sub dpi le {exit} {pop} ifelse } for
} bind def
/getCyanScreen {
    FMUseHighFrequencyScreens { CHighAngles CMHighFreqs} {CLowAngles CMLowFreqs} ifelse
        screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getMagentaScreen {
    FMUseHighFrequencyScreens { MHighAngles CMHighFreqs } {MLowAngles CMLowFreqs} ifelse
        screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getYellowScreen {
    FMUseHighFrequencyScreens { YHighTDot YHighFreqs} { YLowTDot YLowFreqs } ifelse
        screenIndex dup 3 1 roll get 3 1 roll get { 3 div
            {2 { 1 add 2 div 3 mul dup floor sub 2 mul 1 sub exch} repeat
            FMSpotFunction } } {/FMSpotFunction load } ifelse
            0.0 exch
} bind def
/getBlackScreen  {
    FMUseHighFrequencyScreens { KHighFreqs } { KLowFreqs } ifelse
        screenIndex get 45.0 /FMSpotFunction load 
} bind def
/getSpotScreen {
    getBlackScreen
} bind def
/getCompositeScreen {
    getBlackScreen
} bind def
/FMSetScreen 
    fMLevel1 { /setscreen load 
    }{ {
        8 dict begin
        /HalftoneType 1 def
        /SpotFunction exch def
        /Angle exch def
        /Frequency exch def
        /AccurateScreens FMUseAcccurateScreens def
        currentdict end sethalftone
    } bind } ifelse
def
/setDefaultScreen {
    FMPColor {
        orgrxfer cvx orggxfer cvx orgbxfer cvx orgxfer cvx setcolortransfer
    }
    {
        orgxfer cvx settransfer
    } ifelse
    orgfreq organgle orgproc cvx setscreen
} bind def
/setCurrentScreen {
    FrameSepIs FMnone eq {
        FMUseDefaultNoSeparationScreen {
            setDefaultScreen
        } {
            getCompositeScreen FMSetScreen
        } ifelse
    } {
        FrameSepIs FMcustom eq {
            FMUseDefaultSpotSeparationScreen {
                setDefaultScreen
            } {
                getSpotScreen FMSetScreen
            } ifelse
        } {
            FMUseDefaultProcessSeparationScreen {
                setDefaultScreen
            } {
                FrameSepIs FMcyan eq {
                    getCyanScreen FMSetScreen
                } {
                    FrameSepIs FMmagenta eq {
                        getMagentaScreen FMSetScreen
                    } {
                        FrameSepIs FMyellow eq {
                            getYellowScreen FMSetScreen
                        } {
                            getBlackScreen FMSetScreen
                        } ifelse
                    } ifelse
                } ifelse
            } ifelse
        } ifelse
    } ifelse 
} bind def
end
    
/FMDOCUMENT { 
    array /FMfonts exch def 
    /#copies exch def
    FrameDict begin
    0 ne /manualfeed exch def
    /paperheight exch def
    /paperwidth exch def
    0 ne /fMNegative exch def 
    0 ne /edown exch def 
    /yscale exch def
    /xscale exch def
    fMLevel1 {
        manualfeed {setmanualfeed} if
        /FMdicttop countdictstack 1 add def 
        /FMoptop count def 
        setpapername 
        manualfeed {true} {papersize} ifelse 
        {manualpapersize} {false} ifelse 
        {desperatepapersize} {false} ifelse 
        {papersizefailure} if
        count -1 FMoptop {pop pop} for
        countdictstack -1 FMdicttop {pop end} for 
        }
        {2 dict
         dup /PageSize [paperwidth paperheight] put
         manualfeed {dup /ManualFeed manualfeed put} if
         {setpagedevice} stopped {papersizefailure} if
        }
    ifelse 
    
    FMPColor {
        currentcolorscreen
            cvlit /orgproc exch def
                  /organgle exch def 
                  /orgfreq exch def
            cvlit /orgbproc exch def
                  /orgbangle exch def 
                  /orgbfreq exch def
            cvlit /orggproc exch def
                  /orggangle exch def 
                  /orggfreq exch def
            cvlit /orgrproc exch def
                  /orgrangle exch def 
                  /orgrfreq exch def
            currentcolortransfer 
            fMNegative {
                1 1 4 { 
                    pop { 1 exch sub } fmConcatProcs 4 1 roll
                } for
                4 copy
                setcolortransfer
            } if
            cvlit /orgxfer exch def
            cvlit /orgbxfer exch def
            cvlit /orggxfer exch def
            cvlit /orgrxfer exch def
    } {
        currentscreen 
            cvlit /orgproc exch def
                  /organgle exch def 
                  /orgfreq exch def
                  
        currenttransfer 
        fMNegative {
            { 1 exch sub } fmConcatProcs
            dup settransfer
        } if 
        cvlit /orgxfer exch def
    } ifelse
    end 
} def 
/FMBEGINPAGE { 
    FrameDict begin 
    /pagesave save def
    3.86 setmiterlimit
    /landscape exch 0 ne def
    landscape { 
        90 rotate 0 exch dup /pwid exch def neg translate pop 
    }{
        pop /pwid exch def
    } ifelse
    edown { [-1 0 0 1 pwid 0] concat } if
    0 0 moveto paperwidth 0 lineto paperwidth paperheight lineto 
    0 paperheight lineto 0 0 lineto 1 setgray fill
    xscale yscale scale
    /orgmatrix matrix def
    gsave 
} def 
/FMENDPAGE {
    grestore 
    pagesave restore
    end 
    showpage
    } def 
/FMFONTDEFINE { 
    FrameDict begin
    findfont 
    ReEncode 
    1 index exch 
    definefont 
    FMfonts 3 1 roll 
    put
    end 
    } def 
/FMFILLS {
    FrameDict begin dup
    array /fillvals exch def
    dict /patCache exch def
    end 
    } def 
/FMFILL {
    FrameDict begin
     fillvals 3 1 roll put
    end 
    } def 
/FMNORMALIZEGRAPHICS { 
    newpath
    1 setlinewidth
    0 setlinecap
    0 0 0 sethsbcolor
    0 setgray 
    } bind def
/FMBEGINEPSF { 
    end 
    /FMEPSF save def 
    /showpage {} def 
% See Adobe's "PostScript Language Reference Manual, 2nd Edition", page 714.
% "...the following operators MUST NOT be used in an EPS file:" (emphasis ours)
    /banddevice {(banddevice) FMBADEPSF} def
    /clear {(clear) FMBADEPSF} def
    /cleardictstack {(cleardictstack) FMBADEPSF} def 
    /copypage {(copypage) FMBADEPSF} def
    /erasepage {(erasepage) FMBADEPSF} def
    /exitserver {(exitserver) FMBADEPSF} def
    /framedevice {(framedevice) FMBADEPSF} def
    /grestoreall {(grestoreall) FMBADEPSF} def
    /initclip {(initclip) FMBADEPSF} def
    /initgraphics {(initgraphics) FMBADEPSF} def
    /quit {(quit) FMBADEPSF} def
    /renderbands {(renderbands) FMBADEPSF} def
    /setglobal {(setglobal) FMBADEPSF} def
    /setpagedevice {(setpagedevice) FMBADEPSF} def
    /setshared {(setshared) FMBADEPSF} def
    /startjob {(startjob) FMBADEPSF} def
    /lettertray {(lettertray) FMBADEPSF} def
    /letter {(letter) FMBADEPSF} def
    /lettersmall {(lettersmall) FMBADEPSF} def
    /11x17tray {(11x17tray) FMBADEPSF} def
    /11x17 {(11x17) FMBADEPSF} def
    /ledgertray {(ledgertray) FMBADEPSF} def
    /ledger {(ledger) FMBADEPSF} def
    /legaltray {(legaltray) FMBADEPSF} def
    /legal {(legal) FMBADEPSF} def
    /statementtray {(statementtray) FMBADEPSF} def
    /statement {(statement) FMBADEPSF} def
    /executivetray {(executivetray) FMBADEPSF} def
    /executive {(executive) FMBADEPSF} def
    /a3tray {(a3tray) FMBADEPSF} def
    /a3 {(a3) FMBADEPSF} def
    /a4tray {(a4tray) FMBADEPSF} def
    /a4 {(a4) FMBADEPSF} def
    /a4small {(a4small) FMBADEPSF} def
    /b4tray {(b4tray) FMBADEPSF} def
    /b4 {(b4) FMBADEPSF} def
    /b5tray {(b5tray) FMBADEPSF} def
    /b5 {(b5) FMBADEPSF} def
    FMNORMALIZEGRAPHICS 
    [/fy /fx /fh /fw /ury /urx /lly /llx] {exch def} forall 
    fx fw 2 div add fy fh 2 div add  translate
    rotate
    fw 2 div neg fh 2 div neg translate
    fw urx llx sub div fh ury lly sub div scale 
    llx neg lly neg translate 
    /FMdicttop countdictstack 1 add def 
    /FMoptop count def 
    } bind def
/FMENDEPSF {
    count -1 FMoptop {pop pop} for 
    countdictstack -1 FMdicttop {pop end} for 
    FMEPSF restore
    FrameDict begin 
    } bind def
FrameDict begin 
/setmanualfeed {
%%BeginFeature *ManualFeed True
     statusdict /manualfeed true put
%%EndFeature
    } bind def
/max {2 copy lt {exch} if pop} bind def
/min {2 copy gt {exch} if pop} bind def
/inch {72 mul} def
/pagedimen { 
    paperheight sub abs 16 lt exch 
    paperwidth sub abs 16 lt and
    {/papername exch def} {pop} ifelse
    } bind def
/setpapername { 
    /papersizedict 14 dict def 
    papersizedict begin
    /papername /unknown def 
        /Letter 8.5 inch 11.0 inch pagedimen
        /LetterSmall 7.68 inch 10.16 inch pagedimen
        /Tabloid 11.0 inch 17.0 inch pagedimen
        /Ledger 17.0 inch 11.0 inch pagedimen
        /Legal 8.5 inch 14.0 inch pagedimen
        /Statement 5.5 inch 8.5 inch pagedimen
        /Executive 7.5 inch 10.0 inch pagedimen
        /A3 11.69 inch 16.5 inch pagedimen
        /A4 8.26 inch 11.69 inch pagedimen
        /A4Small 7.47 inch 10.85 inch pagedimen
        /B4 10.125 inch 14.33 inch pagedimen
        /B5 7.16 inch 10.125 inch pagedimen
    end
    } bind def
/papersize {
    papersizedict begin
        /Letter {lettertray letter} def
        /LetterSmall {lettertray lettersmall} def
        /Tabloid {11x17tray 11x17} def
        /Ledger {ledgertray ledger} def
        /Legal {legaltray legal} def
        /Statement {statementtray statement} def
        /Executive {executivetray executive} def
        /A3 {a3tray a3} def
        /A4 {a4tray a4} def
        /A4Small {a4tray a4small} def
        /B4 {b4tray b4} def
        /B5 {b5tray b5} def
        /unknown {unknown} def
    papersizedict dup papername known {papername} {/unknown} ifelse get
    end
    statusdict begin stopped end 
    } bind def
/manualpapersize {
    papersizedict begin
        /Letter {letter} def
        /LetterSmall {lettersmall} def
        /Tabloid {11x17} def
        /Ledger {ledger} def
        /Legal {legal} def
        /Statement {statement} def
        /Executive {executive} def
        /A3 {a3} def
        /A4 {a4} def
        /A4Small {a4small} def
        /B4 {b4} def
        /B5 {b5} def
        /unknown {unknown} def
    papersizedict dup papername known {papername} {/unknown} ifelse get
    end
    stopped 
    } bind def
/desperatepapersize {
    statusdict /setpageparams known
        {
        paperwidth paperheight 0 1 
        statusdict begin
        {setpageparams} stopped 
        end
        } {true} ifelse 
    } bind def
/papersizefailure {
    FMAllowPaperSizeMismatch not
        {
(The requested paper size is not available in any currently-installed tray)
(Edit the PS file to "FMAllowPaperSizeMismatch true" to use default tray)
         FMFAILURE } if
    } def
/DiacriticEncoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
/numbersign /dollar /percent /ampersand /quotesingle /parenleft
/parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K
/L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash
/bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h
/i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar
/braceright /asciitilde /.notdef /Adieresis /Aring /Ccedilla /Eacute
/Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis
/atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis
/iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve
/ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex
/udieresis /dagger /.notdef /cent /sterling /section /bullet
/paragraph /germandbls /registered /copyright /trademark /acute
/dieresis /.notdef /AE /Oslash /.notdef /.notdef /.notdef /.notdef
/yen /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown
/exclamdown /logicalnot /.notdef /florin /.notdef /.notdef
/guillemotleft /guillemotright /ellipsis /.notdef /Agrave /Atilde
/Otilde /OE /oe /endash /emdash /quotedblleft /quotedblright
/quoteleft /quoteright /.notdef /.notdef /ydieresis /Ydieresis
/fraction /currency /guilsinglleft /guilsinglright /fi /fl /daggerdbl
/periodcentered /quotesinglbase /quotedblbase /perthousand
/Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave /Iacute
/Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex /.notdef /Ograve
/Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde /macron
/breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
] def
/ReEncode { 
    dup 
    length 
    dict begin 
    {
    1 index /FID ne 
        {def} 
        {pop pop} ifelse 
    } forall 
    0 eq {/Encoding DiacriticEncoding def} if 
    currentdict 
    end 
    } bind def
FMPColor 
    
    {
    /BEGINBITMAPCOLOR { 
        BITMAPCOLOR} def
    /BEGINBITMAPCOLORc { 
        BITMAPCOLORc} def
    /BEGINBITMAPTRUECOLOR { 
        BITMAPTRUECOLOR } def
    /BEGINBITMAPTRUECOLORc { 
        BITMAPTRUECOLORc } def
    /BEGINBITMAPCMYK { 
        BITMAPCMYK } def
    /BEGINBITMAPCMYKc { 
        BITMAPCMYKc } def
    }
    
    {
    /BEGINBITMAPCOLOR { 
        BITMAPGRAY} def
    /BEGINBITMAPCOLORc { 
        BITMAPGRAYc} def
    /BEGINBITMAPTRUECOLOR { 
        BITMAPTRUEGRAY } def
    /BEGINBITMAPTRUECOLORc { 
        BITMAPTRUEGRAYc } def
    /BEGINBITMAPCMYK { 
        BITMAPCMYKGRAY } def
    /BEGINBITMAPCMYKc { 
        BITMAPCMYKGRAYc } def
    }
ifelse
/K { 
    FMPrintAllColorsAsBlack {
        dup 1 eq 2 index 1 eq and 3 index 1 eq and not
            {7 {pop} repeat 0 0 0 1 0 0 0} if
    } if 
    FrameCurColors astore 
    pop combineColor
} bind def
/graymode true def
fMLevel1 {
    /fmGetFlip {
        fMatrix2 exch get mul 0 lt { -1 } { 1 } ifelse
    } FmBD
} if
/setPatternMode {
    fMLevel1 {
        2 index patScreenDict exch known {
            pop pop
            patScreenDict exch get aload pop 
            freq                                 
            mul                                    
            5 2 roll                            
            fMatrix2 currentmatrix 1 get 0 ne {
                3 -1 roll 90 add 3 1 roll         
                sflipx 1 fmGetFlip sflipy 2 fmGetFlip neg mul
            } {                                  
                sflipx 0 fmGetFlip sflipy 3 fmGetFlip mul 
            } ifelse
            0 lt {exch pop} {pop} ifelse         
            fMNegative { 
                {neg} fmConcatProcs             
            } if
            bind
            
            
            
            systemdict /setscreen get exec        
            /FrameCurGray exch def
        } {
            /bwidth  exch def
            /bpside  exch def
            /bstring exch def
            /onbits 0 def  /offbits 0 def
            freq sangle landscape {90 add} if 
                {/ypoint exch def
                 /xpoint exch def
                 /xindex xpoint 1 add 2 div bpside mul cvi def
                 /yindex ypoint 1 add 2 div bpside mul cvi def
                 bstring yindex bwidth mul xindex 8 idiv add get
                 1 7 xindex 8 mod sub bitshift and 0 ne fMNegative {not} if
                 {/onbits  onbits  1 add def 1}
                 {/offbits offbits 1 add def 0}
                 ifelse
                }
                setscreen
            offbits offbits onbits add div fMNegative {1.0 exch sub} if
            /FrameCurGray exch def
        } ifelse
    } { 
        pop pop
        dup patCache exch known {
            patCache exch get
        } { 
            dup
            patDict /bstring 3 -1 roll put
            patDict 
            9 PatFreq screenIndex get div dup matrix scale
            makepattern
            dup 
            patCache 4 -1 roll 3 -1 roll put
        } ifelse
        /FrameCurGray 0 def
        /FrameCurPat exch def
    } ifelse
    /graymode false def
    combineColor
} bind def
/setGrayScaleMode {
    graymode not {
        /graymode true def
        fMLevel1 {
            setCurrentScreen
        } if
    } if
    /FrameCurGray exch def
    combineColor
} bind def
/normalize {
    transform round exch round exch itransform
    } bind def
/dnormalize {
    dtransform round exch round exch idtransform
    } bind def
/lnormalize { 
    0 dtransform exch cvi 2 idiv 2 mul 1 add exch idtransform pop
    } bind def
/H { 
    lnormalize setlinewidth
    } bind def
/Z {
    setlinecap
    } bind def
    
/PFill {
    graymode fMLevel1 or not {
        gsave 1 setgray eofill grestore
    } if
} bind def
/PStroke {
    graymode fMLevel1 or not {
        gsave 1 setgray stroke grestore
    } if
    stroke
} bind def
/X { 
    fillvals exch get
    dup type /stringtype eq
    {8 1 setPatternMode} 
    {setGrayScaleMode}
    ifelse
    } bind def
/V { 
    PFill gsave eofill grestore
    } bind def
/Vclip {
    clip
    } bind def
/Vstrk {
    currentlinewidth exch setlinewidth PStroke setlinewidth
    } bind def
/N { 
    PStroke
    } bind def
/Nclip {
    strokepath clip newpath
    } bind def
/Nstrk {
    currentlinewidth exch setlinewidth PStroke setlinewidth
    } bind def
/M {newpath moveto} bind def
/E {lineto} bind def
/D {curveto} bind def
/O {closepath} bind def
/L { 
     /n exch def
    newpath
    normalize
    moveto 
    2 1 n {pop normalize lineto} for
    } bind def
/Y { 
    L 
    closepath
    } bind def
/R { 
    /y2 exch def
    /x2 exch def
    /y1 exch def
    /x1 exch def
    x1 y1
    x2 y1
    x2 y2
    x1 y2
    4 Y 
    } bind def
/rarc 
    {rad 
     arcto
    } bind def
/RR { 
    /rad exch def
    normalize
    /y2 exch def
    /x2 exch def
    normalize
    /y1 exch def
    /x1 exch def
    mark
    newpath
    {
    x1 y1 rad add moveto
    x1 y2 x2 y2 rarc
    x2 y2 x2 y1 rarc
    x2 y1 x1 y1 rarc
    x1 y1 x1 y2 rarc
    closepath
    } stopped {x1 y1 x2 y2 R} if 
    cleartomark
    } bind def
/RRR { 
    /rad exch def
    normalize /y4 exch def /x4 exch def
    normalize /y3 exch def /x3 exch def
    normalize /y2 exch def /x2 exch def
    normalize /y1 exch def /x1 exch def
    newpath
    normalize moveto 
    mark
    {
    x2 y2 x3 y3 rarc
    x3 y3 x4 y4 rarc
    x4 y4 x1 y1 rarc
    x1 y1 x2 y2 rarc
    closepath
    } stopped
     {x1 y1 x2 y2 x3 y3 x4 y4 newpath moveto lineto lineto lineto closepath} if
    cleartomark
    } bind def
/C { 
    grestore
    gsave
    R 
    clip
    setCurrentScreen
} bind def
/CP { 
    grestore
    gsave
    Y 
    clip
    setCurrentScreen
} bind def
/F { 
    FMfonts exch get
    FMpointsize scalefont
    setfont
    } bind def
/Q { 
    /FMpointsize exch def
    F 
    } bind def
/T { 
    moveto show
    } bind def
/RF { 
    rotate
    0 ne {-1 1 scale} if
    } bind def
/TF { 
    gsave
    moveto 
    RF
    show
    grestore
    } bind def
/P { 
    moveto
    0 32 3 2 roll widthshow
    } bind def
/PF { 
    gsave
    moveto 
    RF
    0 32 3 2 roll widthshow
    grestore
    } bind def
/S { 
    moveto
    0 exch ashow
    } bind def
/SF { 
    gsave
    moveto
    RF
    0 exch ashow
    grestore
    } bind def
/B { 
    moveto
    0 32 4 2 roll 0 exch awidthshow
    } bind def
/BF { 
    gsave
    moveto
    RF
    0 32 4 2 roll 0 exch awidthshow
    grestore
    } bind def
/G { 
    gsave
    newpath
    normalize translate 0.0 0.0 moveto 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath 
    PFill fill
    grestore
    } bind def
/Gstrk {
    savematrix
    newpath
    2 index 2 div add exch 3 index 2 div sub exch 
    normalize 2 index 2 div sub exch 3 index 2 div add exch 
    translate
    scale 
    0.0 0.0 1.0 5 3 roll arc 
    restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
    } bind def
/Gclip { 
    newpath
    savematrix
    normalize translate 0.0 0.0 moveto 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath 
    clip newpath
    restorematrix
    } bind def
/GG { 
    gsave
    newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
    PFill
    fill
    grestore
    } bind def
/GGclip { 
    savematrix
    newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
    clip newpath
    restorematrix
    } bind def
/GGstrk { 
    savematrix
    newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath 
    restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
    } bind def
/A { 
    gsave
    savematrix
    newpath
    2 index 2 div add exch 3 index 2 div sub exch 
    normalize 2 index 2 div sub exch 3 index 2 div add exch 
    translate 
    scale 
    0.0 0.0 1.0 5 3 roll arc 
    restorematrix
    PStroke
    grestore
    } bind def
/Aclip {
    newpath
    savematrix
    normalize translate 0.0 0.0 moveto 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath 
    strokepath clip newpath
    restorematrix
} bind def
/Astrk {
    Gstrk
} bind def
/AA { 
    gsave
    savematrix
    newpath
    
    3 index 2 div add exch 4 index 2 div sub exch 
    
    normalize 3 index 2 div sub exch 4 index 2 div add exch
    translate 
    rotate 
    scale 
    0.0 0.0 1.0 5 3 roll arc 
    restorematrix
    PStroke
    grestore
    } bind def
/AAclip {
    savematrix
    newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
    strokepath clip newpath
    restorematrix
} bind def
/AAstrk {
    GGstrk
} bind def
/BEGINPRINTCODE { 
    /FMdicttop countdictstack 1 add def 
    /FMoptop count 7 sub def 
    /FMsaveobject save def
    userdict begin 
    /showpage {} def 
    FMNORMALIZEGRAPHICS 
    3 index neg 3 index neg translate
    } bind def
/ENDPRINTCODE {
    count -1 FMoptop {pop pop} for 
    countdictstack -1 FMdicttop {pop end} for 
    FMsaveobject restore 
    } bind def
/gn { 
    0 
    {    46 mul 
        cf read pop 
        32 sub 
        dup 46 lt {exit} if 
        46 sub add 
        } loop
    add 
    } bind def
/cfs { 
    /str sl string def 
    0 1 sl 1 sub {str exch val put} for 
    str def 
    } bind def
/ic [ 
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
    0
    {0 hx} {1 hx} {2 hx} {3 hx} {4 hx} {5 hx} {6 hx} {7 hx} {8 hx} {9 hx}
    {10 hx} {11 hx} {12 hx} {13 hx} {14 hx} {15 hx} {16 hx} {17 hx} {18 hx}
    {19 hx} {gn hx} {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}
    {13} {14} {15} {16} {17} {18} {19} {gn} {0 wh} {1 wh} {2 wh} {3 wh}
    {4 wh} {5 wh} {6 wh} {7 wh} {8 wh} {9 wh} {10 wh} {11 wh} {12 wh}
    {13 wh} {14 wh} {gn wh} {0 bl} {1 bl} {2 bl} {3 bl} {4 bl} {5 bl} {6 bl}
    {7 bl} {8 bl} {9 bl} {10 bl} {11 bl} {12 bl} {13 bl} {14 bl} {gn bl}
    {0 fl} {1 fl} {2 fl} {3 fl} {4 fl} {5 fl} {6 fl} {7 fl} {8 fl} {9 fl}
    {10 fl} {11 fl} {12 fl} {13 fl} {14 fl} {gn fl}
    ] def
/ms { 
    /sl exch def 
    /val 255 def 
    /ws cfs 
    /im cfs 
    /val 0 def 
    /bs cfs 
    /cs cfs 
    } bind def
400 ms 
/ip { 
    is 
    0 
    cf cs readline pop 
    {    ic exch get exec 
        add 
        } forall 
    pop 
    
    } bind def
/rip { 
       
      
      bis ris copy pop 
      is
      0
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop pop 
      ris gis copy pop 
      dup is exch 
      
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop pop
      gis bis copy pop 
      dup add is exch 
      
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop 
      
      } bind def
/rip4 { 
       
      
      kis cis copy pop 
      is
      0
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop pop 
      cis mis copy pop 
      dup is exch 
      
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop pop
      mis yis copy pop 
      dup dup add is exch 
      
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop pop
      yis kis copy pop 
      3 mul is exch 
      
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop 
      
      } bind def
/wh { 
    /len exch def 
    /pos exch def 
    ws 0 len getinterval im pos len getinterval copy pop
    pos len 
    } bind def
/bl { 
    /len exch def 
    /pos exch def 
    bs 0 len getinterval im pos len getinterval copy pop
    pos len 
    } bind def
/s1 1 string def
/fl { 
    /len exch def 
    /pos exch def 
    /val cf s1 readhexstring pop 0 get def
    pos 1 pos len add 1 sub {im exch val put} for
    pos len 
    } bind def
/hx { 
    3 copy getinterval 
    cf exch readhexstring pop pop 
    } bind def
/wbytes { 
      dup dup
      8 gt { pop 8 idiv mul }
      { 8 eq {pop} {1 eq {7 add 8 idiv} {3 add 4 idiv} ifelse} ifelse } ifelse
    } bind def
/BEGINBITMAPBWc { 
    1 {} COMMONBITMAPc
    } bind def
/BEGINBITMAPGRAYc { 
    8 {} COMMONBITMAPc
    } bind def
/BEGINBITMAP2BITc { 
    2 {} COMMONBITMAPc
    } bind def
/COMMONBITMAPc { 
         
    /cvtProc exch def
    /depth exch def
    gsave
    
    3 index 2 div add exch    
    4 index 2 div add exch    
    translate        
    rotate            
    1 index 2 div neg    
    1 index 2 div neg    
    translate        
    scale            
    /height exch def /width exch def
    /lb width depth wbytes def 
    sl lb lt {lb ms} if 
    /bitmapsave save def 
    cvtProc                
    /is im 0 lb getinterval def 
    ws 0 lb getinterval is copy pop 
    /cf currentfile def 
    width height depth [width 0 0 height neg 0 height] 
    {ip} image 
    bitmapsave restore 
    grestore
    } bind def
/BEGINBITMAPBW { 
    1 {} COMMONBITMAP
    } bind def
/BEGINBITMAPGRAY { 
    8 {} COMMONBITMAP
    } bind def
/BEGINBITMAP2BIT { 
    2 {} COMMONBITMAP
    } bind def
/COMMONBITMAP { 
    /cvtProc exch def
    /depth exch def
    gsave
    
    3 index 2 div add exch    
    4 index 2 div add exch    
    translate        
    rotate            
    1 index 2 div neg    
    1 index 2 div neg    
    translate        
    scale            
    /height exch def /width exch def
    /bitmapsave save def 
    cvtProc              
    /is width depth wbytes string def
    /cf currentfile def 
    width height depth [width 0 0 height neg 0 height] 
    {cf is readhexstring pop} image
    bitmapsave restore 
    grestore
    } bind def
/ngrayt 256 array def
/nredt 256 array def
/nbluet 256 array def
/ngreent 256 array def
fMLevel1 {
/colorsetup {
    currentcolortransfer
    /gryt exch def
    /blut exch def
    /grnt exch def
    /redt exch def
    0 1 255 {
        /indx exch def
        /cynu 1 red indx get 255 div sub def
        /magu 1 green indx get 255 div sub def
        /yelu 1 blue indx get 255 div sub def
        /kk cynu magu min yelu min def
        /u kk currentundercolorremoval exec def
%        /u 0 def
        nredt indx 1 0 cynu u sub max sub redt exec put
        ngreent indx 1 0 magu u sub max sub grnt exec put
        nbluet indx 1 0 yelu u sub max sub blut exec put
        ngrayt indx 1 kk currentblackgeneration exec sub gryt exec put
    } for
    {255 mul cvi nredt exch get}
    {255 mul cvi ngreent exch get}
    {255 mul cvi nbluet exch get}
    {255 mul cvi ngrayt exch get}
    setcolortransfer
    {pop 0} setundercolorremoval
    {} setblackgeneration
    } bind def
}
{
/colorSetup2 {
    [ /Indexed /DeviceRGB 255 
        {dup red exch get 255 div 
         exch dup green exch get 255 div 
         exch blue exch get 255 div}
    ] setcolorspace
} bind def
} ifelse
/fakecolorsetup {
    /tran 256 string def
    0 1 255 {/indx exch def 
        tran indx
        red indx get 77 mul
        green indx get 151 mul
        blue indx get 28 mul
        add add 256 idiv put} for
    currenttransfer
    {255 mul cvi tran exch get 255.0 div}
    exch fmConcatProcs settransfer
} bind def
/BITMAPCOLOR { 
    /depth 8 def
    gsave
    
    3 index 2 div add exch    
    4 index 2 div add exch    
    translate        
    rotate            
    1 index 2 div neg    
    1 index 2 div neg    
    translate        
    scale            
    /height exch def /width exch def
    /bitmapsave save def
    fMLevel1 {    
        colorsetup
        /is width depth wbytes string def
        /cf currentfile def 
        width height depth [width 0 0 height neg 0 height] 
        {cf is readhexstring pop} {is} {is} true 3 colorimage 
    } {
        colorSetup2
        /is width depth wbytes string def
        /cf currentfile def 
        7 dict dup begin
            /ImageType 1 def
            /Width width def
            /Height height def
            /ImageMatrix [width 0 0 height neg 0 height] def
            /DataSource {cf is readhexstring pop} bind def
            /BitsPerComponent depth def
            /Decode [0 255] def
        end image    
    } ifelse
    bitmapsave restore 
    grestore
    } bind def
/BITMAPCOLORc { 
    /depth 8 def
    gsave
    
    3 index 2 div add exch    
    4 index 2 div add exch    
    translate        
    rotate            
    1 index 2 div neg    
    1 index 2 div neg    
    translate        
    scale            
    /height exch def /width exch def
    /lb width depth wbytes def 
    sl lb lt {lb ms} if 
    /bitmapsave save def 
    fMLevel1 {    
        colorsetup
        /is im 0 lb getinterval def 
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        width height depth [width 0 0 height neg 0 height] 
        {ip} {is} {is} true 3 colorimage
    } {
        colorSetup2
        /is im 0 lb getinterval def 
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        7 dict dup begin
            /ImageType 1 def
            /Width width def
            /Height height def
            /ImageMatrix [width 0 0 height neg 0 height] def
            /DataSource {ip} bind def
            /BitsPerComponent depth def
            /Decode [0 255] def
        end image    
    } ifelse
    bitmapsave restore 
    grestore
    } bind def
/BITMAPTRUECOLORc { 
    /depth 24 def
        gsave
     
    3 index 2 div add exch    
    4 index 2 div add exch    
    translate        
    rotate            
    1 index 2 div neg    
    1 index 2 div neg    
    translate        
    scale            
    /height exch def /width exch def
    /lb width depth wbytes def 
    sl lb lt {lb ms} if 
    /bitmapsave save def 
        
    /is im 0 lb getinterval def    
    /ris im 0 width getinterval def    
    /gis im width width getinterval def    
    /bis im width 2 mul width getinterval def 
        
    ws 0 lb getinterval is copy pop 
    /cf currentfile def 
    width height 8 [width 0 0 height neg 0 height] 
    {width rip pop ris} {gis} {bis} true 3 colorimage
    bitmapsave restore 
    grestore
    } bind def
/BITMAPCMYKc { 
    /depth 32 def
        gsave
     
    3 index 2 div add exch    
    4 index 2 div add exch    
    translate        
    rotate            
    1 index 2 div neg    
    1 index 2 div neg    
    translate        
    scale            
    /height exch def /width exch def
    /lb width depth wbytes def 
    sl lb lt {lb ms} if 
    /bitmapsave save def 
        
    /is im 0 lb getinterval def    
    /cis im 0 width getinterval def    
    /mis im width width getinterval def    
    /yis im width 2 mul width getinterval def 
    /kis im width 3 mul width getinterval def 
        
    ws 0 lb getinterval is copy pop 
    /cf currentfile def 
    width height 8 [width 0 0 height neg 0 height] 
    {width rip4 pop cis} {mis} {yis} {kis} true 4 colorimage
    bitmapsave restore 
    grestore
    } bind def
/BITMAPTRUECOLOR { 
        gsave
        
        3 index 2 div add exch    
        4 index 2 div add exch    
        translate        
        rotate            
        1 index 2 div neg    
        1 index 2 div neg    
        translate        
        scale            
        /height exch def /width exch def
        /bitmapsave save def 
        /is width string def
        /gis width string def
        /bis width string def
        /cf currentfile def 
        width height 8 [width 0 0 height neg 0 height] 
        { cf is readhexstring pop } 
        { cf gis readhexstring pop } 
        { cf bis readhexstring pop } 
        true 3 colorimage 
        bitmapsave restore 
        grestore
        } bind def
/BITMAPCMYK { 
        gsave
        
        3 index 2 div add exch    
        4 index 2 div add exch    
        translate        
        rotate            
        1 index 2 div neg    
        1 index 2 div neg    
        translate        
        scale            
        /height exch def /width exch def
        /bitmapsave save def 
        /is width string def
        /mis width string def
        /yis width string def
        /kis width string def
        /cf currentfile def 
        width height 8 [width 0 0 height neg 0 height] 
        { cf is readhexstring pop } 
        { cf mis readhexstring pop } 
        { cf yis readhexstring pop } 
        { cf kis readhexstring pop } 
        true 4 colorimage 
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUEGRAYc { 
    /depth 24 def
        gsave
    
    3 index 2 div add exch    
    4 index 2 div add exch    
    translate        
    rotate            
    1 index 2 div neg    
    1 index 2 div neg    
    translate        
    scale            
    /height exch def /width exch def
    /lb width depth wbytes def 
    sl lb lt {lb ms} if 
        /bitmapsave save def 
        
    /is im 0 lb getinterval def    
    /ris im 0 width getinterval def    
    /gis im width width getinterval def    
    /bis im width 2 mul width getinterval def 
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        width height 8 [width 0 0 height neg 0 height] 
        {width rip pop ris gis bis width gray} image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPCMYKGRAYc { 
    /depth 32 def
        gsave
    
    3 index 2 div add exch    
    4 index 2 div add exch    
    translate        
    rotate            
    1 index 2 div neg    
    1 index 2 div neg    
    translate        
    scale            
    /height exch def /width exch def
    /lb width depth wbytes def 
    sl lb lt {lb ms} if 
        /bitmapsave save def 
        
    /is im 0 lb getinterval def    
    /cis im 0 width getinterval def    
    /mis im width width getinterval def    
    /yis im width 2 mul width getinterval def 
    /kis im width 3 mul width getinterval def 
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        width height 8 [width 0 0 height neg 0 height] 
        {width rip pop cis mis yis kis width cgray} image
        bitmapsave restore 
        grestore
        } bind def
/cgray { 
        /ww exch def
        /k exch def
        /y exch def
        /m exch def
        /c exch def
        0 1 ww 1 sub { /i exch def c i get m i get y i get k i get CMYKtoRGB
                .144 mul 3 1 roll .587 mul 3 1 roll .299 mul add add
                c i 3 -1 roll floor cvi put } for
        c
         } bind def
/gray { 
        /ww exch def
        /b exch def
        /g exch def
        /r exch def
        0 1 ww 1 sub { /i exch def r i get .299 mul g i get .587 mul
            b i get .114 mul add add r i 3 -1 roll floor cvi put } for
        r
        } bind def
/BITMAPTRUEGRAY { 
        gsave
        
        3 index 2 div add exch    
        4 index 2 div add exch    
        translate        
        rotate            
        1 index 2 div neg    
        1 index 2 div neg    
        translate        
        scale            
        /height exch def /width exch def
        /bitmapsave save def 
        /is width string def
        /gis width string def
        /bis width string def
        /cf currentfile def 
        width height 8 [width 0 0 height neg 0 height] 
        { cf is readhexstring pop 
          cf gis readhexstring pop 
          cf bis readhexstring pop width gray}  image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPCMYKGRAY { 
        gsave
        
        3 index 2 div add exch    
        4 index 2 div add exch    
        translate        
        rotate            
        1 index 2 div neg    
        1 index 2 div neg    
        translate        
        scale            
        /height exch def /width exch def
        /bitmapsave save def 
        /is width string def
        /yis width string def
        /mis width string def
        /kis width string def
        /cf currentfile def 
        width height 8 [width 0 0 height neg 0 height] 
        { cf is readhexstring pop 
          cf mis readhexstring pop 
          cf yis readhexstring pop 
          cf kis readhexstring pop width cgray}  image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPGRAY { 
    8 {fakecolorsetup} COMMONBITMAP
    } bind def
/BITMAPGRAYc { 
    8 {fakecolorsetup} COMMONBITMAPc
    } bind def
/ENDBITMAP {
    } bind def
end 
    /ALDmatrix matrix def ALDmatrix currentmatrix pop
/StartALD {
    /ALDsave save def
     savematrix
     ALDmatrix setmatrix
    } bind def
/InALD {
     restorematrix
    } bind def
/DoneALD {
     ALDsave restore
    } bind def
/I { setdash } bind def
/J { [] 0 setdash } bind def
%%EndProlog
%%BeginSetup
(5.0) FMVERSION
1 1 0 0 612 792 0 1 17 FMDOCUMENT
0 0 /Times-Bold FMFONTDEFINE
1 0 /Times-Italic FMFONTDEFINE
2 0 /Times-Roman FMFONTDEFINE
3 0 /Courier-Bold FMFONTDEFINE
4 1 /Symbol FMFONTDEFINE
5 0 /Helvetica-Bold FMFONTDEFINE
6 0 /Helvetica-BoldOblique FMFONTDEFINE
32 FMFILLS
0 0 FMFILL
1 0.1 FMFILL
2 0.3 FMFILL
3 0.5 FMFILL
4 0.7 FMFILL
5 0.9 FMFILL
6 0.97 FMFILL
7 1 FMFILL
8 <0f1e3c78f0e1c387> FMFILL
9 <0f87c3e1f0783c1e> FMFILL
10 <cccccccccccccccc> FMFILL
11 <ffff0000ffff0000> FMFILL
12 <8142241818244281> FMFILL
13 <03060c183060c081> FMFILL
14 <8040201008040201> FMFILL
16 1 FMFILL
17 0.9 FMFILL
18 0.7 FMFILL
19 0.5 FMFILL
20 0.3 FMFILL
21 0.1 FMFILL
22 0.03 FMFILL
23 0 FMFILL
24 <f0e1c3870f1e3c78> FMFILL
25 <f0783c1e0f87c3e1> FMFILL
26 <3333333333333333> FMFILL
27 <0000ffff0000ffff> FMFILL
28 <7ebddbe7e7dbbd7e> FMFILL
29 <fcf9f3e7cf9f3f7e> FMFILL
30 <7fbfdfeff7fbfdfe> FMFILL
%%EndSetup
%%Page: "4" 1
%%BeginPaperSize: Letter
%%EndPaperSize
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
J
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
54 750.68 540 750.68 2 L
0.25 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
54 75.33 540 75.33 2 L
2 Z
N
0 12 Q
(4) 54 59.9 T
1 10 Q
(FIN) 189 59.9 T
(AL PR) 204.84 59.9 T
(OJECT REPORT) 230.83 59.9 T
1 1 0 0 0 0 1 K
0 12 Q
1 1 0 0 0 0 1 K
(CLINICAL APPLICA) 189 653.98 T
(TION) 304.19 653.98 T
0 0 0 1 0 0 0 K
2 F
0 0 0 1 0 0 0 K
(Although most of the research has been done on the simulated and natu-) 189 625.98 T
(ral image data, the boundary estimation with ripple \336lter is applicable to) 189 611.98 T
-0.05 (medical images as well. It pro) 189 597.98 P
-0.05 (v) 332.56 597.98 P
-0.05 (ed to be accurate and ef) 338.38 597.98 P
-0.05 (fecti) 451.46 597.98 P
-0.05 (v) 472.49 597.98 P
-0.05 (e for e) 478.31 597.98 P
-0.05 (xtract-) 508.68 597.98 P
(ing contours of bon) 189 583.98 T
(y structures from CT images and can be applied to) 282.48 583.98 T
(data acquired from dif) 189 569.98 T
(ferent modalities as well. The ripple \336lter can be) 295.67 569.98 T
(ef) 189 555.98 T
(fecti) 198.02 555.98 T
(v) 219.05 555.98 T
(ely used in a semi-automatic se) 224.87 555.98 T
(gmentation process where an) 375 555.98 T
(e) 189 541.98 T
(xpert mak) 194.15 541.98 T
(es \336rst rough estimate of the boundaries. Se) 242.35 541.98 T
(gmented data can) 452.15 541.98 T
(be used for e) 189 527.98 T
(xample to create 3D geometrical models.) 250.46 527.98 T
1 1 0 0 0 0 1 K
0 F
1 1 0 0 0 0 1 K
(CONCLUSIONS) 189 471.98 T
0 0 0 1 0 0 0 K
2 F
0 0 0 1 0 0 0 K
-0.05 (There is a lot that can be done to optimize the performance and accurac) 189 443.98 P
-0.05 (y) 531.05 443.98 P
(of the process of boundary estimation with the ripple \336lter) 189 429.98 T
(. V) 467.98 429.98 T
(arious) 481.31 429.98 T
(approaches e) 189 415.98 T
(xist to estimate the boundary model. Some simpli\336cations) 251.12 415.98 T
-0.17 (can be made in calculating the lik) 189 401.98 P
-0.17 (elihood to mak) 349.15 401.98 P
-0.17 (e it less computationally) 420.69 401.98 P
(e) 189 387.98 T
(xpensi) 194.15 387.98 T
(v) 225.18 387.98 T
(e. The algorithm can be run in parallel in man) 231 387.98 T
(y re) 450.78 387.98 T
(gions through-) 468.92 387.98 T
(out the image making it high-speed.) 189 373.98 T
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "4" 1
%%Page: "3" 2
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
72 750.68 558 750.68 2 L
0.25 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
72 75.33 558 75.33 2 L
2 Z
N
1 10 Q
(FIN) 207 59.9 T
(AL PR) 222.84 59.9 T
(OJECT REPORT) 248.83 59.9 T
0 12 Q
(3) 552 59.9 T
3 10 Q
(\245) 207 681.98 T
2 12 Q
(Gaussian noise is added to the image) 220.74 681.98 T
-0.36 (Right from these assumptions one can assume that this implementation is) 207 653.98 P
(not going to be too successful, if at all possible to apply) 207 639.98 T
(, on medical) 473.54 639.98 T
-0.23 (images. First of all, medical images do not ha) 207 625.98 P
-0.23 (v) 423.6 625.98 P
-0.23 (e constant gray le) 429.42 625.98 P
-0.23 (v) 512.75 625.98 P
-0.23 (el inten-) 518.57 625.98 P
-0.48 (sities between the object and the background, and the noise distrib) 207 611.98 P
-0.48 (ution is) 520.28 611.98 P
(not a Gaussian representation. This implementation starts based on a) 207 597.98 T
-0.29 (rough estimate of the boundaries does not w) 207 583.98 P
-0.29 (ork with images in which the) 417.12 583.98 P
(object includes holes and multiple contours.) 207 569.98 T
0 1 0 0 1 0 1 K
1 F
0 1 0 0 1 0 1 K
(Boundary Model) 207 541.98 T
0 0 0 1 0 0 0 K
2 F
0 0 0 1 0 0 0 K
-0.16 (An edge sequence modeled as a Mark) 207 513.98 P
-0.16 (o) 387.85 513.98 P
-0.16 (v process is implemented in order) 393.67 513.98 P
(to calculate a rough boundary) 207 499.98 T
(. A state is represented by a se) 348.85 499.98 T
(gment con-) 493.97 499.98 T
(taining k points. In order to do the transition between state) 207 485.98 T
1 10 Q
(i) 490.31 485.98 T
2 12 Q
( and) 493.09 485.98 T
1 10 Q
(i+1) 516.42 485.98 T
2 12 Q
(tran-) 533.95 485.98 T
(sition probabilities ha) 207 471.98 T
(v) 310.76 471.98 T
(e to be calculated. Using e) 316.58 471.98 T
(xpected shape or) 443.04 471.98 T
(curv) 207 457.98 T
(ature as a guide, functions for state transition can be de) 228.02 457.98 T
(vised. The) 492 457.98 T
(boundary to be made is to ha) 207 443.98 T
(v) 345.41 443.98 T
(e smooth, gradual curv) 351.23 443.98 T
(es. T) 461.03 443.98 T
(o achie) 483.4 443.98 T
(v) 517.42 443.98 T
(e this) 523.24 443.98 T
(arcs are \336tted through pix) 207 429.98 T
(els of a state. The e) 330.13 429.98 T
(xpected v) 422.59 429.98 T
(alue of the ne) 468.61 429.98 T
(xt) 533.41 429.98 T
(pix) 207 415.98 T
(el is on an e) 222.16 415.98 T
(xtension of the arc \336tted through the pre) 279.3 415.98 T
(vious k pix) 471.97 415.98 T
(els.) 525.13 415.98 T
0 1 0 0 1 0 1 K
1 F
0 1 0 0 1 0 1 K
(Successive Gr) 207 387.98 T
(owing-Shrinking Pr) 274.1 387.98 T
(ocess) 368.57 387.98 T
0 0 0 1 0 0 0 K
2 F
0 0 0 1 0 0 0 K
(The process proceeds one pix) 207 359.98 T
(el at a time along the length of the present) 348.78 359.98 T
-0.24 (boundary) 207 345.98 P
-0.24 (. F) 251.54 345.98 P
-0.24 (or each element in the initial boundary estimate there are tw) 263.8 345.98 P
-0.24 (o) 549.24 345.98 P
(pix) 207 331.98 T
(els adjacent to it, one on the inside and another on the outside. W) 222.16 331.98 T
(e) 534.16 331.98 T
-0.27 (reclassifying the inside pix) 207 317.98 P
-0.27 (els as an outside, the outside - as an inside and) 335 317.98 P
(compute the log lik) 207 303.98 T
(elihoods. By choosing the maximum of the lik) 299.88 303.98 T
(eli-) 522.43 303.98 T
(hoods we decide whether we should k) 207 289.98 T
(eep the old boundary or choose of) 389.51 289.98 T
(the tw) 207 275.98 T
(o ne) 236.54 275.98 T
(w boundaries. The process is successi) 256.57 275.98 T
(v) 437.57 275.98 T
(ely repeated for ne) 443.39 275.98 T
(wly) 532.72 275.98 T
(created boundaries. Thus the section of the boundary that is lying within) 207 261.98 T
(the object will tend to gro) 207 247.98 T
(w outw) 330.36 247.98 T
(ards while the section within the back-) 365.9 247.98 T
(ground will tend to shrink inw) 207 233.98 T
(ards.) 352.55 233.98 T
1 1 0 0 0 0 1 K
0 F
1 1 0 0 0 0 1 K
(RESUL) 207 205.98 T
(TS) 245.9 205.98 T
0 0 0 1 0 0 0 K
2 F
0 0 0 1 0 0 0 K
(Experimental results sho) 207 177.98 T
(w that the algorithm being reasonably f) 325.36 177.98 T
(ast is) 513.88 177.98 T
(capable of estimating the boundary of a single object in images with sig-) 207 163.98 T
-0.24 (nal-to-noise ratio do) 207 149.98 P
-0.24 (wn to 1 with reasonable accurac) 303.54 149.98 P
-0.24 (y) 456.45 149.98 P
-0.24 (. Ho) 461.67 149.98 P
-0.24 (we) 481.8 149.98 P
-0.24 (v) 495.49 149.98 P
-0.24 (er) 501.31 149.98 P
-0.24 (, the algo-) 510.15 149.98 P
(rithm is performing v) 207 135.98 T
(ery poorly on images with multiple objects and on) 309.82 135.98 T
(discontinuties.) 207 121.98 T
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "3" 2
%%Page: "2" 3
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
54 750.68 540 750.68 2 L
0.25 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
54 75.33 540 75.33 2 L
2 Z
N
0 12 Q
(2) 54 59.9 T
1 10 Q
(FIN) 189 59.9 T
(AL PR) 204.84 59.9 T
(OJECT REPORT) 230.83 59.9 T
2 12 Q
(boundary are classi\336ed as object or background, probabilities are going) 189 681.98 T
(to be associated with possible pix) 189 667.98 T
(el intensities, and computed probabili-) 349.81 667.98 T
-0.21 (ties of the boundary \050from se) 189 653.98 P
-0.21 (v) 326.64 653.98 P
-0.21 (eral dif) 332.46 653.98 P
-0.21 (ferent h) 366.27 653.98 P
-0.21 (ypothesized boundaries\051 are) 402.99 653.98 P
(going to be calculated. The process of calculating the maximum lik) 189 639.98 T
(eli-) 511.84 639.98 T
(hood is going to mak) 189 625.98 T
(e use of all these probabilities as follo) 290.22 625.98 T
(ws: The joint) 471.56 625.98 T
(lik) 189 557.98 T
(elihood of the boundary and the image data can in turn be di) 201.55 557.98 T
(vided fur-) 490.54 557.98 T
(ther into the probability of the length of the boundary times the prboba-) 189 543.98 T
(bility of the edge. Probability of the image data is calcualted after a) 189 529.98 T
(Gaussian formulation and the probability of the edge element being for-) 189 515.98 T
(ground or background is:) 189 501.98 T
(T) 189 389.98 T
(aking the log of this e) 195.37 389.98 T
(xpression gi) 299.52 389.98 T
(v) 357.55 389.98 T
(es us the   log lik) 363.37 389.98 T
(elihood which) 444.59 389.98 T
(serv) 189 375.98 T
(es as a cost function to be minimized while reclassifying neighbor-) 208.81 375.98 T
(hood   pix) 189 361.98 T
(els.) 237.16 361.98 T
1 1 0 0 0 0 1 K
0 F
1 1 0 0 0 0 1 K
(IMPLEMENT) 189 305.98 T
(A) 263.26 305.98 T
(TION) 270.78 305.98 T
0 0 0 1 0 0 0 K
2 F
0 0 0 1 0 0 0 K
(As w) 189 277.98 T
(as described in the pre) 213.88 277.98 T
(vious section, the implementation consists of) 320.88 277.98 T
(three important steps.) 189 263.98 T
0 1 0 0 1 0 1 K
1 F
0 1 0 0 1 0 1 K
(Pictur) 189 235.98 T
(e Model) 218.56 235.98 T
0 0 0 1 0 0 0 K
2 F
0 0 0 1 0 0 0 K
(The picture model is based on man) 189 207.98 T
(y assumptions, in order to get the) 356.8 207.98 T
(accurac) 189 193.98 T
(y of the algorithm.) 225.46 193.98 T
3 10 Q
(\245) 189 172.98 T
2 12 Q
(there is one object in the picture) 202.74 172.98 T
3 10 Q
(\245) 189 154.98 T
2 12 Q
(the object has constant gray le) 202.74 154.98 T
(v) 347.42 154.98 T
(el intensities r) 353.24 154.98 T
2 9.6 Q
(in) 420.57 151.98 T
3 10 Q
(\245) 189 134.78 T
2 12 Q
(the background is of constant gray le) 202.74 134.78 T
(v) 379.74 134.78 T
(el intensities r) 385.57 134.78 T
2 9.6 Q
(out) 452.9 131.78 T
3 10 Q
(\245) 189 114.58 T
2 12 Q
(resulting picture function is represented by an array of independent) 202.74 114.58 T
(Gaussian random v) 202.74 97.38 T
(ariables of v) 295.1 97.38 T
(ariance s) 354.11 97.38 T
2 9.6 Q
(2) 396.42 102.18 T
189 89.29 540 689.98 C
0 0 0 1 0 0 0 K
195 567.98 534 621.98 C
0 0 0 1 0 0 0 K
0 1 0 0 1 0 1 K
1 10 Q
0 X
0 1 0 0 1 0 1 K
(P) 248.88 592.95 T
(B) 259.69 592.95 T
(o) 266.39 592.95 T
(u) 271.98 592.95 T
(n) 277.57 592.95 T
(d) 283.16 592.95 T
(a) 288.75 592.95 T
(r) 294.34 592.95 T
(y) 299.29 592.95 T
(e) 329.36 592.95 T
(d) 334.39 592.95 T
(a) 339.98 592.95 T
(t) 345.57 592.95 T
(a) 348.94 592.95 T
2 F
(imag) 308.36 592.95 T
4 F
(\050) 255.57 592.95 T
(\051) 354.65 592.95 T
1 F
(P) 373.81 598.5 T
(B) 384.63 598.5 T
(o) 391.33 598.5 T
(u) 396.92 598.5 T
(n) 402.51 598.5 T
(d) 408.1 598.5 T
(a) 413.69 598.5 T
(y) 419.28 598.5 T
(e) 450.31 598.5 T
(d) 455.34 598.5 T
(a) 460.93 598.5 T
(t) 466.52 598.5 T
(a) 469.89 598.5 T
2 F
(imag) 429.31 598.5 T
4 F
(,) 423.72 598.5 T
(\050) 380.51 598.5 T
(\051) 475.6 598.5 T
1 F
(P) 395.89 586.26 T
(e) 428.22 586.26 T
(d) 433.25 586.26 T
(a) 438.84 586.26 T
(t) 444.43 586.26 T
(a) 447.8 586.26 T
2 F
(imag) 407.22 586.26 T
4 F
(\050) 402.6 586.26 T
(\051) 453.51 586.26 T
2 F
(-) 373.81 592.95 T
(-) 375.48 592.95 T
(-) 377.14 592.95 T
(-) 378.81 592.95 T
(-) 380.47 592.95 T
(-) 382.14 592.95 T
(-) 383.8 592.95 T
(-) 385.47 592.95 T
(-) 387.13 592.95 T
(-) 388.8 592.95 T
(-) 390.46 592.95 T
(-) 392.13 592.95 T
(-) 393.79 592.95 T
(-) 395.46 592.95 T
(-) 397.12 592.95 T
(-) 398.79 592.95 T
(-) 400.45 592.95 T
(-) 402.12 592.95 T
(-) 403.78 592.95 T
(-) 405.45 592.95 T
(-) 407.11 592.95 T
(-) 408.78 592.95 T
(-) 410.44 592.95 T
(-) 412.11 592.95 T
(-) 413.77 592.95 T
(-) 415.44 592.95 T
(-) 417.1 592.95 T
(-) 418.77 592.95 T
(-) 420.43 592.95 T
(-) 422.1 592.95 T
(-) 423.76 592.95 T
(-) 425.43 592.95 T
(-) 427.09 592.95 T
(-) 428.76 592.95 T
(-) 430.42 592.95 T
(-) 432.09 592.95 T
(-) 433.75 592.95 T
(-) 435.42 592.95 T
(-) 437.08 592.95 T
(-) 438.75 592.95 T
(-) 440.41 592.95 T
(-) 442.08 592.95 T
(-) 443.74 592.95 T
(-) 445.41 592.95 T
(-) 447.07 592.95 T
(-) 448.74 592.95 T
(-) 450.4 592.95 T
(-) 452.07 592.95 T
(-) 453.73 592.95 T
(-) 455.4 592.95 T
(-) 457.06 592.95 T
(-) 458.73 592.95 T
(-) 460.39 592.95 T
(-) 462.06 592.95 T
(-) 463.72 592.95 T
(-) 465.39 592.95 T
(-) 467.05 592.95 T
(-) 468.72 592.95 T
(-) 470.38 592.95 T
(-) 472.05 592.95 T
(-) 473.71 592.95 T
(-) 475.38 592.95 T
(-) 475.6 592.95 T
(=) 362.98 592.95 T
0 0 0 1 0 0 0 K
0 1 0 0 1 0 1 K
305.73 590.45 305.73 599.45 2 L
0.45 H
2 Z
N
0 0 0 1 0 0 0 K
189 89.29 540 689.98 C
0 0 612 792 C
216 454.02 495 487 C
0 0 0 1 0 0 0 K
0 1 0 0 1 0 1 K
1 9 Q
0 X
0 1 0 0 1 0 1 K
(P) 273.73 479.02 T
(B) 279.76 479.02 T
(P) 304.36 479.02 T
(L) 310.38 479.02 T
(l) 319.58 479.02 T
(e) 322.61 479.02 T
(n) 327.14 479.02 T
(g) 332.17 479.02 T
(t) 337.2 479.02 T
(h) 340.23 479.02 T
4 F
(\050) 315.95 479.02 T
(\051) 345.37 479.02 T
1 F
(P) 367.53 479.02 T
(E) 373.56 479.02 T
4 14 Q
(\325) 355.11 476.41 T
4 9 Q
(\327) 350.61 479.02 T
2 F
(=) 294.79 479.02 T
0 0 0 1 0 0 0 K
2 10 Q
0 0 0 1 0 0 0 K
(\0501\051 Line) 396 479.02 T
(boundary) 431 479.17 T
0 0 0 1 0 0 0 K
J
0 0 612 792 C
189 89.29 540 689.98 C
189 405 540 441 C
0 0 0 1 0 0 0 K
0 1 0 0 1 0 1 K
1 9 Q
0 X
0 1 0 0 1 0 1 K
(P) 208.51 427 T
(E) 214.54 427 T
(e) 224.41 427 T
4 F
(\050) 220.78 427 T
(\051) 229.05 427 T
1 F
(P) 246.11 427 T
(g) 255.77 427 T
1 7 Q
(l) 260.61 424.1 T
(e) 263.1 424.1 T
(f) 266.75 424.1 T
(t) 269.23 424.1 T
(t) 271.71 424.1 T
(s) 274.2 424.1 T
(i) 277.46 424.1 T
(d) 279.94 424.1 T
(e) 283.98 424.1 T
1 9 Q
(r) 296.08 427 T
1 7 Q
(b) 300.13 424.1 T
(a) 304.17 424.1 T
(c) 308.21 424.1 T
(k) 311.86 424.1 T
(g) 315.5 424.1 T
(r) 319.54 424.1 T
(o) 322.8 424.1 T
(u) 326.84 424.1 T
(n) 330.88 424.1 T
(d) 334.92 424.1 T
2 9 Q
(\320) 289.34 427 T
4 F
(\050) 252.14 427 T
(\051) 339.24 427 T
1 F
(P) 348.98 427 T
(g) 358.65 427 T
1 7 Q
(r) 363.49 424.1 T
(i) 366.75 424.1 T
(g) 369.23 424.1 T
(h) 373.27 424.1 T
(t) 377.31 424.1 T
(s) 379.79 424.1 T
(i) 383.05 424.1 T
(d) 385.54 424.1 T
(e) 389.58 424.1 T
1 9 Q
(r) 401.68 427 T
1 7 Q
(f) 406.76 424.1 T
(o) 409.24 424.1 T
(r) 413.28 424.1 T
(e) 416.54 424.1 T
(g) 420.19 424.1 T
(r) 424.23 424.1 T
(o) 427.49 424.1 T
(u) 431.52 424.1 T
(n) 435.56 424.1 T
(d) 439.6 424.1 T
2 9 Q
(\320) 394.93 427 T
4 F
(\050) 355.01 427 T
(\051) 443.93 427 T
(\327) 344.49 427 T
2 F
(=) 236.54 427 T
0 0 0 1 0 0 0 K
2 10 Q
0 0 0 1 0 0 0 K
(\0502\051) 463.03 427 T
(Edge element) 477.69 427 T
0 0 0 1 0 0 0 K
189 89.29 540 689.98 C
0 0 612 792 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "2" 3
%%Page: "1" 4
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
72 750.68 198 750.68 2 L
0.25 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
5 9 Q
(Ma) 72 737.84 T
(y 22, 1997) 84.32 737.84 T
72 444.68 558 444.68 2 L
2 Z
N
72 75.33 558 75.33 2 L
N
0 12 Q
(1) 552 59.9 T
1 1 0 0 0 0 1 K
1 24 Q
1 1 0 0 0 0 1 K
-0.88 (FIN) 207 659 S
-0.88 (AL PR) 242.37 659 S
-0.88 (OJECT) 300.33 659 S
0 0 0 1 0 0 0 K
1 1 0 0 0 0 1 K
-0.88 (REPORT) 207 629 S
0 0 0 1 0 0 0 K
0 1 0 0 1 0 1 K
6 18 Q
0 1 0 0 1 0 1 K
(Ripple \336lter in sequential) 207 573 T
0 0 0 1 0 0 0 K
0 1 0 0 1 0 1 K
(boundar) 207 549 T
(y estimation algorithm) 279.18 549 T
0 0 0 1 0 0 0 K
1 1 0 0 0 0 1 K
0 10 Q
1 1 0 0 0 0 1 K
(MONICA MA) 207 510.33 T
(URER) 268.43 510.33 T
0 0 0 1 0 0 0 K
1 1 0 0 0 0 1 K
0 12 Q
(Medical Imaging) 207 497 T
0 10 Q
(                  EN292S13) 297 497 T
0 0 0 1 0 0 0 K
1 1 0 0 0 0 1 K
(Br) 207 484.33 T
(o) 217.93 484.33 T
(wn Uni) 222.83 484.33 T
(v) 253.57 484.33 T
(ersity) 258.47 484.33 T
0 0 0 1 0 0 0 K
1 1 0 0 0 0 1 K
0 12 Q
(THEOR) 207 421.98 T
(Y REVIEW) 249.92 421.98 T
0 0 0 1 0 0 0 K
2 F
0 0 0 1 0 0 0 K
-0.15 (The Ripple \336lter is an algorithm for \336nding object boundaries. Boundary) 207 393.98 P
(\336nding is treated as a statistical lik) 207 379.98 T
(elihood maximization problem, while) 372.88 379.98 T
(modeling of the data into e) 207 365.98 T
(xpected boundary structure, object and back-) 335.81 365.98 T
-0.38 (ground is taking place. As boundary \336nding is an important step in image) 207 351.98 P
(analysis, this algorithm helps with image se) 207 337.98 T
(gmentation into homoge-) 416.48 337.98 T
-0.16 (neous re) 207 323.98 P
-0.16 (gions, object orientation, and object boundary \336nding. This algo-) 246.98 323.98 P
-0.09 (rithm shares edge follo) 207 309.98 P
-0.09 (wing concepts, b) 316.74 309.98 P
-0.09 (ut is as a whole dif) 397.3 309.98 P
-0.09 (ferent through) 486.87 309.98 P
-0.27 (its lik) 207 295.98 P
-0.27 (elihood maximization analysis. There are se) 233.62 295.98 P
-0.27 (v) 443.27 295.98 P
-0.27 (eral important steps in) 449.09 295.98 P
(the algorithm, which are:) 207 281.98 T
3 10 Q
(\245) 207 260.98 T
2 12 Q
(picture model) 220.74 260.98 T
3 10 Q
(\245) 207 242.98 T
2 12 Q
(h) 220.74 242.98 T
(ypothesized boundary model \050contour determination; Mark) 226.68 242.98 T
(o) 510.86 242.98 T
(v) 516.68 242.98 T
(processes\051) 220.74 228.98 T
3 10 Q
(\245) 207 210.98 T
2 12 Q
(successi) 220.74 210.98 T
(v) 259.77 210.98 T
(ely adjusting the boundary by lik) 265.59 210.98 T
(elihood estimation for) 423.8 210.98 T
(neighborhood pix) 220.74 196.98 T
(els) 305.56 196.98 T
(These steps will be discussed in detail in the implementation section of) 207 168.98 T
-0.33 (this report. The boundary estimation initializes the algorithm by tracing a) 207 154.98 P
(contour around the object. This contour does not ha) 207 140.98 T
(v) 454.39 140.98 T
(e to be too accurate) 460.21 140.98 T
(and in this implementation it has been done through a kth order Mark) 207 126.98 T
(o) 540.18 126.98 T
(v) 546 126.98 T
(process. A lik) 207 112.98 T
(elihood estimate approach is going to be e) 273.2 112.98 T
(x) 475.33 112.98 T
(ecuted on this) 481.15 112.98 T
(initial estimate of the boundary \050a rough one\051. The pix) 207 98.98 T
(els ne) 467.45 98.98 T
(xt to the) 494.93 98.98 T
FMENDPAGE
%%EndPage: "1" 4
%%Trailer
%%BoundingBox: 0 0 612 792
%%PageOrder: Descend
%%Pages: 4
%%DocumentFonts: Times-Bold
%%+ Times-Italic
%%+ Times-Roman
%%+ Courier-Bold
%%+ Symbol
%%+ Helvetica-Bold
%%+ Helvetica-BoldOblique
%%EOF
