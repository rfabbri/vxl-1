/*------------------------------------------------------------*\
 * File: propagate.c
 *
 * Functions:
 *    CedtPropagateDist
 *    InitDiagPlanePropagateDist
 *    InitDiagCubePropagateDist *    AddToFrontAndHeap
 *    CedtRecordMedialAxes
 *
 * History:
 *    #0: mid-February 1998, by F.Leymarie
 *    #1: mid-April 1998: added CedtRecordMedialAxes(), F.L.
 \*------------------------------------------------------------*/

#include "propagate3d.h"
#include "vcl_cassert.h"

/*------------------------------------------------------------*\
 * Function: CedtPropagateDist
 *
 * Usage: Euclidean Distance Propagation by CEDT
 \*------------------------------------------------------------*/
    void
CedtPropagateDist(Heap *pTheHeap, Cedt3d *pTheCedt,
        VectLoc *pTheVect, Dimension *pTheDim)
{
    int    iOldPos,  iCnt, iCntMax, iSliceSize, iXdim;
    dir_t iDir;
    int    iOldX, iOldY, iOldZ, iStepX, iStepY, iStepZ;
    int    iNewX, iNewY, iNewZ, iNewPos;
    offset_t    fDistX, fDistY, fDistZ, fOldDistX, fOldDistY, fOldDistZ;
    dist_sq_t    dDist;
    Mask    theMask;
    Distance    theDist;

    iSliceSize = pTheDim->iSliceSize;
    iXdim = pTheDim->iXdim;

    theMask.iDir = iDir = pTheVect->iDir;
    SetMask(&theMask);
    iCntMax = theMask.iNumMaskEl;

    iOldX = pTheVect->ix; iOldY = pTheVect->iy; iOldZ = pTheVect->iz;
    iOldPos =  pTheVect->iPos;

    int sloc = pTheCedt->sourceLoc[iOldPos];
    int sourceLocZ = sloc / pTheDim->iSliceSize;
    int sourceLocY = (sloc - pTheDim->iSliceSize*sourceLocZ)/pTheDim->iXdim;
    int sourceLocX = (sloc - pTheDim->iSliceSize*sourceLocZ)%pTheDim->iXdim;

    int calcfOldDistZ = iOldZ - sourceLocZ;
    int calcfOldDistY = iOldY - sourceLocY;
    int calcfOldDistX = iOldX - sourceLocX;

    fOldDistX = calcfOldDistX;
    fOldDistY = calcfOldDistY;
    fOldDistZ = calcfOldDistZ;

    for(iCnt = 0; iCnt < iCntMax; iCnt++)
    {
        iStepX = theMask.iStepX[iCnt];
        iStepY = theMask.iStepY[iCnt];
        iStepZ = theMask.iStepZ[iCnt];

        fDistX = fOldDistX + iStepX;
        fDistY = fOldDistY + iStepY;
        fDistZ = fOldDistZ + iStepZ;
        dDist = (fDistX*fDistX + fDistY*fDistY + fDistZ*fDistZ);

        iNewX = iOldX + iStepX;
        iNewY = iOldY + iStepY;
        iNewZ = iOldZ + iStepZ;
        iNewPos = iNewZ*iSliceSize + iNewY*iXdim + iNewX;

        if(iNewPos < pTheDim->iWSpaceSize && iNewPos > 0){
          if (pTheCedt->pdDtArray[iNewPos] > dDist) /* New Min Dist --> Update */
          {
            theDist.fdx = fDistX;
            theDist.fdy = fDistY;
            theDist.fdz = fDistZ;

            theDist.dd2 = dDist;

            pTheVect->ix = iNewX;
            pTheVect->iy = iNewY;
            pTheVect->iz = iNewZ;
            pTheVect->iPos = iNewPos;
            pTheVect->iDir = iDir;

            if( (pTheVect->iz < pTheDim->iZdim)&& 
                (pTheVect->ix < pTheDim->iXdim)&&
                (pTheVect->iy < pTheDim->iYdim)&&
                 (pTheVect->iz >= 0 )&& 
                 (pTheVect->ix >= 0 )&&
                 (pTheVect->iy >= 0 )) {
              AddToFrontAndHeap(pTheHeap, pTheCedt, &theDist, pTheVect,pTheDim);
            }
          }
        }
    }
    return;
}

/*------------------------------------------------------------*\
 * Function: InitDiagPlanePropagateDist
 *
 * Usage: Init the propagation along diagonals of DISTANCE in planes
 *     that is, for 2D masks.
 *    The planes are generated by rotations of 45^o along the
 *    3 axes X, Y, Z  of the X0Z, XY0 & 0YZ planes.
 \*------------------------------------------------------------*/
    void
InitDiagPlanePropagateDist(Heap *pTheHeap, Cedt3d *pTheCedt,
        VectLoc *pTheVect, Dimension *pTheDim)
{
    int    iOldPos, iCnt, iCntMax, iSliceSize, iXdim;
    dir_t iDiagDir, New2dMasks[2];
    int    iOldX, iOldY, iOldZ, iStepX, iStepY, iStepZ;
    int    iNewX, iNewY, iNewZ, iNewPos, iN;
    offset_t    fDistX, fDistY, fDistZ, fOldDistX, fOldDistY, fOldDistZ;
    dist_sq_t    dDist;
    Mask    theMask;
    Distance    theDist;

    iSliceSize = pTheDim->iSliceSize;
    iXdim = pTheDim->iXdim;

    iOldX = pTheVect->ix; iOldY = pTheVect->iy; iOldZ = pTheVect->iz;
    iOldPos =  pTheVect->iPos;

    int sloc = pTheCedt->sourceLoc[iOldPos];
    int sourceLocZ = sloc / pTheDim->iSliceSize;
    int sourceLocY = (sloc - pTheDim->iSliceSize*sourceLocZ)/pTheDim->iXdim;
    int sourceLocX = (sloc - pTheDim->iSliceSize*sourceLocZ)%pTheDim->iXdim;
    int calcfOldDistZ = iOldZ - sourceLocZ;
    int calcfOldDistY = iOldY - sourceLocY;
    int calcfOldDistX = iOldX - sourceLocX;

    fOldDistX = calcfOldDistX;
    fOldDistY = calcfOldDistY;
    fOldDistZ = calcfOldDistZ;

    /****  1st : Set the diagonal element : just another DSPM ****/

    theMask.iDir = iDiagDir = pTheVect->iDir;
    SetMask(&theMask);
    iCntMax = theMask.iNumMaskEl;    /* Must be equal to 1  */
    if(iCntMax != 1) {
        fprintf(stderr, "ERROR: a DSPM must have only one voxel element... exiting\n");
        exit(11);
    }

    iStepX = theMask.iStepX[0];
    iStepY = theMask.iStepY[0];
    iStepZ = theMask.iStepZ[0];

    fDistX = fOldDistX + iStepX;
    fDistY = fOldDistY + iStepY;
    fDistZ = fOldDistZ + iStepZ;
    dDist = (fDistX*fDistX + fDistY*fDistY + fDistZ*fDistZ);

    iNewX = iOldX + iStepX;
    iNewY = iOldY + iStepY;
    iNewZ = iOldZ + iStepZ;
    iNewPos = iNewZ*iSliceSize + iNewY*iXdim + iNewX;

    if(iNewPos < pTheDim->iWSpaceSize && iNewPos > 0){
      if (pTheCedt->pdDtArray[iNewPos] > dDist)    /* New Min Dist --> Update */
      {
              theDist.fdx = fDistX;
              theDist.fdy = fDistY;
              theDist.fdz = fDistZ;

        theDist.dd2 = dDist;

        pTheVect->ix = iNewX;
        pTheVect->iy = iNewY;
        pTheVect->iz = iNewZ;
        pTheVect->iPos = iNewPos;
        pTheVect->iDir = iDiagDir;

            if( (pTheVect->iz < pTheDim->iZdim)&& 
                (pTheVect->ix < pTheDim->iXdim)&&
                (pTheVect->iy < pTheDim->iYdim)&&
                 (pTheVect->iz >= 0 )&& 
                 (pTheVect->ix >= 0 )&&
                 (pTheVect->iy >= 0 )) {
        AddToFrontAndHeap(pTheHeap, pTheCedt, &theDist, pTheVect,pTheDim);
            }
      }
    }

    /****  2nd : Set the 2 Intermediate masks on each side of the diagonal ****/

    SetPlaneOffDiagMasks(iDiagDir, New2dMasks);

    for(iN = 0; iN < 2; iN++)
    {
        theMask.iDir = New2dMasks[iN];
        SetMask(&theMask);
        iCntMax = theMask.iNumMaskEl;    /* Must be equal to 2 */
        if(iCntMax != 2) 
        {
            fprintf(stderr, "ERROR: an IGPM2 must have only 2 voxel elements... exiting\n");
            exit(11);
        }

        for(iCnt = 0; iCnt < iCntMax; iCnt++)
        {
            iStepX = theMask.iStepX[iCnt];
            iStepY = theMask.iStepY[iCnt];
            iStepZ = theMask.iStepZ[iCnt];

            fDistX = fOldDistX +  iStepX;
            fDistY = fOldDistY +  iStepY;
            fDistZ = fOldDistZ +  iStepZ;
            dDist = (fDistX*fDistX + fDistY*fDistY + fDistZ*fDistZ);

            iNewX = iOldX + iStepX;
            iNewY = iOldY + iStepY;
            iNewZ = iOldZ + iStepZ;
            iNewPos = iNewZ*iSliceSize + iNewY*iXdim + iNewX;

            if(iNewPos < pTheDim->iWSpaceSize && iNewPos > 0){
              if (pTheCedt->pdDtArray[iNewPos] > dDist)    /* New Min Dist --> Update */
              {
                     theDist.fdx = fDistX;
                     theDist.fdy = fDistY;
                     theDist.fdz = fDistZ;
              
                theDist.dd2 = dDist;

                pTheVect->ix = iNewX;
                pTheVect->iy = iNewY;
                pTheVect->iz = iNewZ;
                pTheVect->iPos = iNewPos;
                pTheVect->iDir = theMask.iDir;

            if( (pTheVect->iz < pTheDim->iZdim)&& 
                (pTheVect->ix < pTheDim->iXdim)&&
                (pTheVect->iy < pTheDim->iYdim)&&
                 (pTheVect->iz >= 0 )&& 
                 (pTheVect->ix >= 0 )&&
                 (pTheVect->iy >= 0 )) { 
              AddToFrontAndHeap(pTheHeap, pTheCedt, &theDist, pTheVect,pTheDim);
            }
              }
            }
        }
    }
    return;
}

/*------------------------------------------------------------*\
 * Function: InitDiagCubePropagateDist
 *
 * Usage: Init the propagation along diagonals of DISTANCE for cube corners
 *     that is, for 3D masks.
 \*------------------------------------------------------------*/
    void
InitDiagCubePropagateDist(Heap *pTheHeap, Cedt3d *pTheCedt,
        VectLoc *pTheVect, Dimension *pTheDim)
{
    int    iOldPos,iCnt, iCntMax, iSliceSize, iXdim;
    dir_t  iDiagDir, New3dMasks[6]; 
    int    iOldX, iOldY, iOldZ, iStepX, iStepY, iStepZ;
    int    iNewX, iNewY, iNewZ, iNewPos, iN;
    offset_t    fDistX, fDistY, fDistZ, fOldDistX, fOldDistY, fOldDistZ;
    dist_sq_t    dDist;
    Mask    theMask;
    Distance    theDist;

    iSliceSize = pTheDim->iSliceSize;
    iXdim = pTheDim->iXdim;

    iOldX = pTheVect->ix; iOldY = pTheVect->iy; iOldZ = pTheVect->iz;
    iOldPos =  pTheVect->iPos;

    int sloc = pTheCedt->sourceLoc[iOldPos];
    int sourceLocZ = sloc / pTheDim->iSliceSize;
    int sourceLocY = (sloc - pTheDim->iSliceSize*sourceLocZ)/pTheDim->iXdim;
    int sourceLocX = (sloc - pTheDim->iSliceSize*sourceLocZ)%pTheDim->iXdim;
    int calcfOldDistZ = iOldZ - sourceLocZ;
    int calcfOldDistY = iOldY - sourceLocY;
    int calcfOldDistX = iOldX - sourceLocX;

    fOldDistX = calcfOldDistX;
    fOldDistY = calcfOldDistY;
    fOldDistZ = calcfOldDistZ;

    /****  1st : Set the diagonal element of the cube : just another DSPM ****/

    theMask.iDir = iDiagDir = pTheVect->iDir;
    SetMask(&theMask);
    iCntMax = theMask.iNumMaskEl;    /* Must be equal to 1  */
    if(iCntMax != 1) {
        fprintf(stderr, "ERROR: a DSPM must have only one voxel element... exiting\n");
        exit(11);
    }

    iStepX = theMask.iStepX[0];
    iStepY = theMask.iStepY[0];
    iStepZ = theMask.iStepZ[0];

    fDistX = fOldDistX + iStepX;
    fDistY = fOldDistY + iStepY;
    fDistZ = fOldDistZ + iStepZ;
    dDist = (fDistX*fDistX + fDistY*fDistY + fDistZ*fDistZ);

    iNewX = iOldX + iStepX;
    iNewY = iOldY + iStepY;
    iNewZ = iOldZ + iStepZ;
    iNewPos = iNewZ*iSliceSize + iNewY*iXdim + iNewX;

        if(iNewPos < pTheDim->iWSpaceSize && iNewPos > 0){
    if (pTheCedt->pdDtArray[iNewPos] > dDist)    /* New Min Dist --> Update */
    {
            theDist.fdx = fDistX;
            theDist.fdy = fDistY;
            theDist.fdz = fDistZ;
    
        theDist.dd2 = dDist;

        pTheVect->ix = iNewX;
        pTheVect->iy = iNewY;
        pTheVect->iz = iNewZ;
        pTheVect->iPos = iNewPos;
        pTheVect->iDir = iDiagDir;

        if( (pTheVect->iz < pTheDim->iZdim)&& 
                (pTheVect->ix < pTheDim->iXdim)&&
                (pTheVect->iy < pTheDim->iYdim)&&
                 (pTheVect->iz >= 0 )&& 
                 (pTheVect->ix >= 0 )&&
                 (pTheVect->iy >= 0 )) { 
              AddToFrontAndHeap(pTheHeap, pTheCedt, &theDist, pTheVect,pTheDim);
            }
    }
        }

    /****  2nd : Set the 3 Intermediate masks for each face making the ****/
    /****         cube corner in the direction of the (cubic) diagonal  ****/

    SetCubicOffDiagMasks(iDiagDir, New3dMasks);

    for(iN = 0; iN < 3; iN++)
    {
        theMask.iDir = New3dMasks[iN];
        SetMask(&theMask);
        iCntMax = theMask.iNumMaskEl;    /* Must be equal to 4 */
        if(iCntMax != 4)
        {
            fprintf(stderr, "ERROR: an IGPM3 must have 4 voxel elements... exiting\n");
            exit(11);
        }

        for(iCnt = 0; iCnt < iCntMax; iCnt++)
        {
            iStepX = theMask.iStepX[iCnt];
            iStepY = theMask.iStepY[iCnt];
            iStepZ = theMask.iStepZ[iCnt];

            fDistX = fOldDistX + iStepX;
            fDistY = fOldDistY + iStepY;
            fDistZ = fOldDistZ + iStepZ;
            dDist = (fDistX*fDistX + fDistY*fDistY + fDistZ*fDistZ);

            iNewX = iOldX + iStepX;
            iNewY = iOldY + iStepY;
            iNewZ = iOldZ + iStepZ;
            iNewPos = iNewZ*iSliceSize + iNewY*iXdim + iNewX;

        if(iNewPos < pTheDim->iWSpaceSize && iNewPos > 0){
            if (pTheCedt->pdDtArray[iNewPos] > dDist)    /* New Min Dist --> Update */
            {
                     theDist.fdx = fDistX;
                     theDist.fdy = fDistY;
                     theDist.fdz = fDistZ;
   
                theDist.dd2 = dDist;

                pTheVect->ix = iNewX;
                pTheVect->iy = iNewY;
                pTheVect->iz = iNewZ;
                pTheVect->iPos = iNewPos;
                pTheVect->iDir = theMask.iDir;



        if( (pTheVect->iz < pTheDim->iZdim)&& 
                (pTheVect->ix < pTheDim->iXdim)&&
                (pTheVect->iy < pTheDim->iYdim)&&
                 (pTheVect->iz >= 0 )&& 
                 (pTheVect->ix >= 0 )&&
                 (pTheVect->iy >= 0 )) { 
              AddToFrontAndHeap(pTheHeap, pTheCedt, &theDist, pTheVect,pTheDim);
            }
            }
        }
        }
    }
    return;
}

/*------------------------------------------------------------*\
 * Function: AddToFrontAndHeap
 *
 * Usage: Updates the propagation Front and the Heap
 \*------------------------------------------------------------*/
    void
AddToFrontAndHeap(Heap *pTheHeap, Cedt3d *pTheCedt,
        Distance *pTheDist, VectLoc *pTheVect, Dimension *pTheDim)
{
    int    iPos = pTheVect->iPos;
    int    iLocInHeap;
    dist_sq_t    dDist = pTheDist->dd2;

    /**** Update the front ****/

    /*
    if(pTheVect->ix-pTheDist->fdx > pTheDim->iXdim || pTheVect->ix-pTheDist->fdx < 0 || 
       pTheVect->iz-pTheDist->fdz > pTheDim->iZdim || pTheVect->iz-pTheDist->fdz < 0 || 
       pTheVect->iy-pTheDist->fdy > pTheDim->iYdim || pTheVect->iy-pTheDist->fdy < 0 ){
            vcl_cout << "AddToFrontAndHeap ";
            vcl_cout << "coords " <<  pTheVect->ix << " " << pTheVect->iy << " " << pTheVect->iz ;
            vcl_cout << "\n";
            vcl_cout << "offset stored " 
                     <<  pTheDist->fdx << " " 
                     <<  pTheDist->fdy << " " 
                     <<  pTheDist->fdz;
            vcl_cout << "\n";
            vcl_cout << "loc stored " 
                     << pTheVect->ix - pTheDist->fdx << " " 
                     << pTheVect->iy - pTheDist->fdy << " " 
                     << pTheVect->iz - pTheDist->fdz;
            vcl_cout << "\n\n";
    }
    */

    pTheCedt->sourceLoc[iPos] = (pTheVect->iz-pTheDist->fdz)*pTheDim->iSliceSize
                               +(pTheVect->iy-pTheDist->fdy)*pTheDim->iXdim 
                               +(pTheVect->ix-pTheDist->fdx);

    /*
    int sloc = pTheCedt->sourceLoc[iPos];
    int sourceLocZ = sloc / pTheDim->iSliceSize;
    int sourceLocY = (sloc - pTheDim->iSliceSize*sourceLocZ)/pTheDim->iXdim;
    int sourceLocX = (sloc - pTheDim->iSliceSize*sourceLocZ)%pTheDim->iXdim;

    vcl_cout << "AddToFront loc " 
            << pTheVect->ix -2 << " " 
            << pTheVect->iy -2  << " " 
            << pTheVect->iz -2;
    vcl_cout << "\t";
    vcl_cout << "AddToFront sourceloc " << sloc << "\t";
    vcl_cout << "AddToFront source " 
            << sourceLocX -2 << " " 
            << sourceLocY -2  << " " 
            << sourceLocZ -2;
    vcl_cout << "\n";
    */
            


    pTheCedt->iDir[iPos] = pTheVect->iDir;

    /**** Updating the heap ****/
    if (pTheHeap->loc[iPos] < 0) { /* 1st time a voxel is visited */
        insert_to_minheap(pTheHeap, iPos, dDist, pTheVect->ix, pTheVect->iy, pTheVect->iz );
    }
    else if (pTheHeap->data[iPos] >= dDist) { /* Already visited but new min distance */
        iLocInHeap = pTheHeap->loc[iPos];
        pTheHeap->data[iPos] = dDist;
        up_minheap(pTheHeap, iLocInHeap);    /* Move it up in the Heap stack */
    }
    else
    {
        fprintf(stderr, "ERROR ... new dist value is larger ... exiting \n");
        exit(11);
    }

    return;
}
