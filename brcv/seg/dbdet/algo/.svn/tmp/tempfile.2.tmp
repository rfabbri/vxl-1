#include "dbdet_sel_base.h"

#include <vcl_iostream.h>
#include <vcl_fstream.h>
#include <vcl_cassert.h>
#include <vcl_deque.h>
#include <vcl_map.h>
#include <vcl_set.h>
#include <vcl_algorithm.h>
#include <vcl_queue.h>

//********************************************************************//
// Functions for constructing hypothesis trees and 
// tracing between contour end points.
//********************************************************************//

#define SM_TH 0.8

dbdet_EHT* dbdet_sel_base::construct_hyp_tree(dbdet_edgel* e)
{
  if (edge_link_graph_.cLinks.size()==0){
    vcl_cout << "No Link Graph !" <<vcl_endl;
    return 0;
  }

  //construct 2 HTs: one in the forward direction and one in the reverse direction
  vcl_queue<dbdet_EHT_node*> BFS_queue;

  //forward HT
  dbdet_EHT* HTF = new dbdet_EHT();

  dbdet_EHT_node* root1 = new dbdet_EHT_node(e);
  HTF->root = root1;
  BFS_queue.push(root1);

  int depth = 0;

  //How far do we wanna go (if we don't hit a node)?
  while (!BFS_queue.empty() && vcl_log10(double(depth))<3)
  {
    dbdet_EHT_node* cur_node = BFS_queue.front();
    BFS_queue.pop();

    //are we at a CFG node? if we are we don't need to go any further
    if (cur_node!= root1 &&
        (curve_frag_graph_.pFrags[cur_node->e->id].size()>0 ||
         curve_frag_graph_.cFrags[cur_node->e->id].size()))
      continue;

    //also if we hit an edgel that is already linked no need to go further (this might ensure planarity)
    if (edge_link_graph_.linked[cur_node->e->id])
      continue;

    //propagate this node
    dbdet_link_list_iter lit = edge_link_graph_.cLinks[cur_node->e->id].begin(); 
    for (; lit != edge_link_graph_.cLinks[cur_node->e->id].end(); lit++)
    {
      if (edge_link_graph_.linked[(*lit)->ce->id]) //don't go tracing in linked contours
        continue;
       
      // don't go tracing when there is unambiguate contour already -----by Yuliang
      if (curve_frag_graph_.pFrags[cur_node->e->id].size()>=1){
        dbdet_edgel_chain *c1=0;
        dbdet_edgel_chain_list_iter fit = curve_frag_graph_.pFrags[cur_node->e->id].begin();
        bool there_is_contour =false;
        for(;fit!=curve_frag_graph_.pFrags[cur_node->e->id].end();fit++){
            c1 =  (*fit);
            if((c1->edgels[0]->id)==((*lit)->ce->id))
              there_is_contour = true;
           }
        if(there_is_contour)
          continue;
       }

      if (curve_frag_graph_.cFrags[cur_node->e->id].size()>=1){
        dbdet_edgel_chain *c1=0;
        dbdet_edgel_chain_list_iter fit = curve_frag_graph_.cFrags[cur_node->e->id].begin();
        bool there_is_contour =false;
        for(;fit!=curve_frag_graph_.cFrags[cur_node->e->id].end();fit++){
            c1 =  (*fit);
            if((c1->edgels.back()->id)==((*lit)->ce->id))
              there_is_contour = true;
           }
        if(there_is_contour)
          continue;
       }

      if (cur_node->parent) {
        //make a simple consistency check
        double dx1 = cur_node->e->pt.x() - cur_node->parent->e->pt.x();
        double dy1 = cur_node->e->pt.y() - cur_node->parent->e->pt.y();
        double dx2 = (*lit)->ce->pt.x() - cur_node->e->pt.x();
        double dy2 = (*lit)->ce->pt.y() - cur_node->e->pt.y();

        if (((dx1*dx2 + dy1*dy2)/vcl_sqrt(dx1*dx1+dy1*dy1)/vcl_sqrt(dx2*dx2+dy2*dy2))<SM_TH) //not consistent
          continue;
      }

      //else extend the tree to this edgel
      dbdet_EHT_node* new_node = new dbdet_EHT_node((*lit)->ce);

      cur_node->add_child(new_node);
      BFS_queue.push(new_node);
      depth++;
    }
  }

  //empty the bfs queue
  while (!BFS_queue.empty())
    BFS_queue.pop();

  return HTF;
}

//: construct all possible EHTs from the terminal nodes and find legal contour paths
void dbdet_sel_base::construct_all_path_from_EHTs()
{
  //go over the contour fragment graph and form an EHT from every terminal node
  //validate each of the paths in the EHT

  vcl_vector<dbdet_edgel_chain*> new_frags;

  //going over the edgemap instead so that an EHT only starts once from a node when there are two 
  //contour fragments terminating there
  for (unsigned i=0; i<edgemap_->edgels.size(); i++)
  {
    dbdet_edgel* eA = edgemap_->edgels[i];

    if (curve_frag_graph_.pFrags[i].size()==0 &&
        curve_frag_graph_.cFrags[i].size()==0)
      continue; //no terminal nodes here

    //1) Terminal node found, construct an EHT from here
    dbdet_EHT* EHT1 = construct_hyp_tree(eA);

    //2) traverse each path and determine its validity
    if (EHT1)
    {
      //traverse the EHT and test all the paths
      dbdet_EHT::path_iterator pit = EHT1->path_begin();
      for (; pit != EHT1->path_end(); pit++){ 
        vcl_vector<dbdet_edgel*>& edgel_chain = pit.get_cur_path();

        dbdet_edgel* le = edgel_chain.back();
        if (curve_frag_graph_.pFrags[le->id].size()==0 &&
            curve_frag_graph_.cFrags[le->id].size()==0)
        {
          //not a valid termination node
          //delete the node associated  with this path ( it will delete the entire path, by definition)
          EHT1->delete_subtree(pit);
          continue; 
        }

        //test this path to see if it is valid
        if (!is_EHT_path_legal(edgel_chain)){
          EHT1->delete_subtree(pit);
          continue;
        }

        //copy this chain
        dbdet_edgel_chain* new_chain = new dbdet_edgel_chain();
        new_chain->append(edgel_chain);
        new_chain->temp = true; //make sure that the new frags are initialized with temp flags

        //new_frags.push_back(new_chain);

        //add path to the CFTG
        curve_frag_graph_.CFTG.insert_fragment(new_chain);

        //now that its added delete the apth
        EHT1->delete_subtree(pit);
      }

      //finally delete the EHT
      delete EHT1;
    }
  }
  vcl_cout<<"Finish constructing all hypothesis trees"<<vcl_endl;
  ////Now add all the new curve fragments into the CFG (as tentative fragments)
  //for (unsigned i=0; i<new_frags.size(); i++)
  //  curve_frag_graph_.insert_fragment(new_frags[i]);
}

//: perform a geometric consistency check to determine whether a given temp path is valid
bool dbdet_sel_base::is_EHT_path_legal(vcl_vector<dbdet_edgel*>& edgel_chain)
{
  //what makes a path legal?
  // (a) if a c1 polyarc bundle can form within it
  // (b) if it is c1 compatible with the end points

  //For now, just check for...

  //1) continuity consistency at the end points
  //1a) at the start point
  dbdet_edgel* eS = edgel_chain.front();
  dbdet_edgel* e2 = edgel_chain[1];
  double dx1 = e2->pt.x() - eS->pt.x();
  double dy1 = e2->pt.y() - eS->pt.y();
  bool cons = false;

  //is this at a start or an end of an unambiguous chain?
  dbdet_edgel_chain_list_iter pcit = curve_frag_graph_.pFrags[eS->id].begin();
  for ( ; pcit != curve_frag_graph_.pFrags[eS->id].end(); pcit++)
  {
    dbdet_edgel* pe = (*pcit)->edgels[(*pcit)->edgels.size()-2];

    //make a simple consistency check  
    double dx2 = eS->pt.x() - pe->pt.x();
    double dy2 = eS->pt.y() - pe->pt.y();

    cons = cons || ((dx1*dx2 + dy1*dy2)/vcl_sqrt(dx1*dx1+dy1*dy1)/vcl_sqrt(dx2*dx2+dy2*dy2))>SM_TH;
  }
  dbdet_edgel_chain_list_iter ccit = curve_frag_graph_.cFrags[eS->id].begin();
  for ( ; ccit != curve_frag_graph_.cFrags[eS->id].end(); ccit++)
  {
    dbdet_edgel* ce = (*ccit)->edgels[1];

    //make a simple consistency check
    double dx2 = eS->pt.x() - ce->pt.x();
    double dy2 = eS->pt.y() - ce->pt.y();

    cons = cons || ((dx1*dx2 + dy1*dy2)/vcl_sqrt(dx1*dx1+dy1*dy1)/vcl_sqrt(dx2*dx2+dy2*dy2))>SM_TH;
  }
  if (!cons) return false; //no good at the start point

  //1b) at the end point
  dbdet_edgel* eE = edgel_chain.back();
  e2 = edgel_chain[edgel_chain.size()-2];
  dx1 = eE->pt.x() - e2->pt.x();
  dy1 = eE->pt.y() - e2->pt.y();
  cons = false;

  //is this at a start or an end of an unambiguous chain?
  pcit = curve_frag_graph_.pFrags[eE->id].begin();
  for ( ; pcit != curve_frag_graph_.pFrags[eE->id].end(); pcit++)
  {
    dbdet_edgel* pe = (*pcit)->edgels[(*pcit)->edgels.size()-2];

    //make a simple consistency check  
    double dx2 = pe->pt.x() - eE->pt.x();
    double dy2 = pe->pt.y() - eE->pt.y();

    cons = cons || ((dx1*dx2 + dy1*dy2)/vcl_sqrt(dx1*dx1+dy1*dy1)/vcl_sqrt(dx2*dx2+dy2*dy2))>SM_TH;
  }
  ccit = curve_frag_graph_.cFrags[eE->id].begin();
  for ( ; ccit != curve_frag_graph_.cFrags[eE->id].end(); ccit++)
  {
    dbdet_edgel* ce = (*ccit)->edgels[1];

    //make a simple consistency check
    double dx2 = ce->pt.x() - eE->pt.x();
    double dy2 = ce->pt.y() - eE->pt.y();

    cons = cons || ((dx1*dx2 + dy1*dy2)/vcl_sqrt(dx1*dx1+dy1*dy1)/vcl_sqrt(dx2*dx2+dy2*dy2))>SM_TH;
  }
  if (!cons) return false; //no good at the end point

  //2)

  //
  //fit_polyarc_to_chain(&edgel_chain);


  return true;
}

//: compute a simple path metric based on the chain and its neighboring support chains
double dbdet_sel_base::compute_path_metric2(vcl_vector<dbdet_edgel*>& Pchain, 
                                           vcl_vector<dbdet_edgel*>& Tchain, 
                                           vcl_vector<dbdet_edgel*>& Cchain)
{
  double cost = 0.0;

  //construct an edgel chain out of all three chains
  vcl_vector<dbdet_edgel*> chain;
  if (Pchain.size())
    for (unsigned i=0; i<Pchain.size(); i++) chain.push_back(Pchain[i]);
  if (Tchain.size())
    for (unsigned i=0; i<Tchain.size(); i++) chain.push_back(Tchain[i]);
  if (Cchain.size())
    for (unsigned i=0; i<Cchain.size(); i++) chain.push_back(Cchain[i]);

  //now compute the metric
  dbdet_edgel *eA=0, *eP=0;
  double dsp = 0, thp = 0;
  double total_ds = 0.0;
  for (unsigned i=1; i<chain.size(); i++)
  {
    eA = chain[i];
    eP = chain[i-1];

    //compute ds
    double ds = vgl_distance(eA->pt, eP->pt);
    total_ds += ds;

    //compute dtheta
    double thc = dbdet_vPointPoint(eP->pt, eA->pt);
    double dt = vcl_fabs(thc-thp);
    dt = (dt>vnl_math::pi)? 2*vnl_math::pi-dt : dt;

    //cost += ds + 10*dt;
    cost += vcl_pow(dt/(ds+dsp), 2.0);

    thp = thc;//save the current vector for the next iteration
    dsp = ds;
  }

  //normalize by arc length(?)
  //cost /= total_ds;

  return cost;
}

bool link_cost_less(dbdet_CFTG_link* link1, dbdet_CFTG_link* link2)
{
  return link1->cost < link2->cost;
}

//: disambiguate the CFG, basically to produce a disjoint set
void dbdet_sel_base::disambiguate_the_CFTG()
{
  //At the moment, I cannot verify that the CTFG is topologically sound (i.e., a planar graph)
  //so within this limit, the goal is to break the links at junctions

  //Alternatively, it is possible to splice the two contours and mark the connection with the others as a junction
  //these others might be pruned off at a postprocessing stage if desired

  //Note: the temp flag on the contours distinguish it from the unambiguous contours

  //A) disambiguate the links first : Only keep the best path
  //   Note: remember to search in both directions

  //go over all the links of the CFTG
  vcl_vector<dbdet_edgel*> dummy_chain;

  dbdet_CFTG_link_list_iter l_it = curve_frag_graph_.CFTG.Links.begin();
  for (; l_it != curve_frag_graph_.CFTG.Links.end(); l_it++)
  {
    dbdet_CFTG_link* cur_Link = (*l_it);

    //is this an ambiguous link?
    if (cur_Link->cCFs.size()>1)
    {
      //needs disambiguation
      double min_cost = 10000;
      dbdet_edgel_chain* best_chain = 0;

      dbdet_edgel_chain_list_iter f_it = cur_Link->cCFs.begin();
      for(; f_it != cur_Link->cCFs.end(); f_it++)
      {
        dbdet_edgel_chain* edgel_chain = (*f_it);
        vcl_vector<dbdet_edgel*> chain(edgel_chain->edgels.begin(), edgel_chain->edgels.end());

        double path_cost = compute_path_metric2(dummy_chain, chain, dummy_chain);
        if (path_cost < min_cost){
          min_cost = path_cost;
          best_chain = edgel_chain;
        }
      }

      //remove all except the best chain
      if (best_chain){
        dbdet_edgel_chain_list_iter f_it = cur_Link->cCFs.begin();
        for(; f_it != cur_Link->cCFs.end(); f_it++)
          if ((*f_it) != best_chain)
            delete (*f_it);

        cur_Link->cCFs.clear();
        cur_Link->cCFs.push_back(best_chain);
        cur_Link->cost = min_cost;
      }
    }
    else { //just comptue cost for this path
      dbdet_edgel_chain* edgel_chain = cur_Link->cCFs.front();
      vcl_vector<dbdet_edgel*> chain(edgel_chain->edgels.begin(), edgel_chain->edgels.end());

      cur_Link->cost = compute_path_metric2(dummy_chain, chain, dummy_chain);
    }
  } 

  //B) disambiguate between duplicates (A-> vs B->A)
  l_it = curve_frag_graph_.CFTG.Links.begin();
  for (; l_it != curve_frag_graph_.CFTG.Links.end(); l_it++)
  {
    dbdet_CFTG_link* cur_Link = (*l_it);

    if (cur_Link->cCFs.size()==0)
      continue;

    //look for the link from the other direction
    dbdet_CFTG_link_list_iter l_it2 = curve_frag_graph_.CFTG.cLinks[cur_Link->eE->id].begin();
    for (; l_it2 != curve_frag_graph_.CFTG.cLinks[cur_Link->eE->id].end(); l_it2++){
      if ((*l_it2)->eE == cur_Link->eS){
        //duplicate found

        if ((*l_it2)->cCFs.size()==0)
          continue;

        dbdet_edgel_chain* edgel_chain1 = cur_Link->cCFs.front();
        dbdet_edgel_chain* edgel_chain2 = (*l_it2)->cCFs.front();

        vcl_vector<dbdet_edgel*> chain1(edgel_chain1->edgels.begin(), edgel_chain1->edgels.end());
        vcl_vector<dbdet_edgel*> chain2(edgel_chain2->edgels.begin(), edgel_chain2->edgels.end());

        double path_cost1 = compute_path_metric2(dummy_chain, chain1, dummy_chain);
        double path_cost2 = compute_path_metric2(dummy_chain, chain2, dummy_chain);

        if (path_cost1<path_cost2){
          //keep current link and delete the other
          delete edgel_chain2;
          (*l_it2)->cCFs.clear();
          (*l_it2)->cost = 1000;
        }
        else{
          delete edgel_chain1;
          cur_Link->cCFs.clear();
          cur_Link->cost = 1000;
        }
      }
    }
  }

  //C) Gradient descent to prune bifurcations from the CFTG

  //go over list of Links and find any with degree > 1
  //these need to be disambiguated (gradient descent)
  vcl_list<dbdet_CFTG_link*> GD_list;

  //populate the map
  l_it = curve_frag_graph_.CFTG.Links.begin();
  for (; l_it != curve_frag_graph_.CFTG.Links.end(); l_it++)
  {
    //compute degree at each end
    int deg = curve_frag_graph_.CFTG.cLinks[(*l_it)->eS->id].size() + curve_frag_graph_.CFTG.pLinks[(*l_it)->eS->id].size();
    if (deg>1){
      GD_list.push_back(*l_it);
      continue;
    }

    deg = curve_frag_graph_.CFTG.cLinks[(*l_it)->eE->id].size() + curve_frag_graph_.CFTG.pLinks[(*l_it)->eE->id].size();
    if (deg>1){
      GD_list.push_back(*l_it);
      continue;
    }
  }
  //sort the cost list
  GD_list.sort(link_cost_less);

  //gradient descent
  while (GD_list.size()>0)
  {
    dbdet_CFTG_link* cur_Link = GD_list.front();
    GD_list.pop_front();

    //now remove the other links connected to the end points of this link
    vcl_vector<dbdet_CFTG_link*> links_to_del;
    l_it = curve_frag_graph_.CFTG.cLinks[cur_Link->eS->id].begin();
    for (; l_it != curve_frag_graph_.CFTG.cLinks[cur_Link->eS->id].end(); l_it++){
      if ((*l_it) != cur_Link)
        links_to_del.push_back((*l_it));
    }

    for (unsigned j=0; j<links_to_del.size(); j++){      
      GD_list.remove(links_to_del[j]);//also remove it from the GD list
      curve_frag_graph_.CFTG.remove_link(links_to_del[j]);
    }
    links_to_del.clear();

    l_it = curve_frag_graph_.CFTG.pLinks[cur_Link->eE->id].begin();
    for (; l_it != curve_frag_graph_.CFTG.pLinks[cur_Link->eE->id].end(); l_it++){
      if ((*l_it) != cur_Link)
        links_to_del.push_back((*l_it));
    }

    for (unsigned j=0; j<links_to_del.size(); j++){
      GD_list.remove(links_to_del[j]);//also remove it from the GD list
      curve_frag_graph_.CFTG.remove_link(links_to_del[j]);
    }
    links_to_del.clear();
  }


  //D) Add it all back to the CFG (clear the CFTG in the process)
  l_it = curve_frag_graph_.CFTG.Links.begin();
  for (; l_it != curve_frag_graph_.CFTG.Links.end(); l_it++)
  {
    if ((*l_it)->cCFs.size()==1)
      curve_frag_graph_.insert_fragment((*l_it)->cCFs.front());
  }
  curve_frag_graph_.CFTG.clear();
  curve_frag_graph_.CFTG.resize(edgemap_->edgels.size());
  vcl_cout<<"Finish disambiguating the CFTG"<<vcl_endl;
}


//: correct the CFG topology to produce a disjoint set
void dbdet_sel_base::correct_CFG_topology()
{
  //D) Final T-junction type disambiguation can be done on the CFG
  // Basically, go over all the nodes of the CFG and operate on the ones with degree>2
  // also merge all segments that are adjacent

  // going over the edgemap instead so that a node is visited only once and so that I
  // don't have to deal with iterator issues


  for (unsigned i=0; i<edgemap_->edgels.size(); i++)
  {
    dbdet_edgel_chain *c1=0, *c2=0;
    dbdet_edgel* eA = edgemap_->edgels[i];

    int deg = curve_frag_graph_.pFrags[i].size()+ curve_frag_graph_.cFrags[i].size();

    if (deg<2)
      continue; //nodes

    if (deg==2){ //degree 2 segments will trigger a splice
      
      //standard operation: extract them from the graph, reorder them, either merge or put them back

      //segments need to meet continuity criteria (simple one for now)
      if (curve_frag_graph_.pFrags[i].size()>1){
        dbdet_edgel_chain_list_iter fit = curve_frag_graph_.pFrags[i].begin();
        c1 =  (*fit); fit++;
        c2 =  (*fit);

        //curve_frag_graph_.extract_fragment(c1);
        //curve_frag_graph_.extract_fragment(c2);

        //reverse the sequence of edgels
        vcl_reverse(c2->edgels.begin(), c2->edgels.end());
      }
      else if (curve_frag_graph_.pFrags[i].size()==1){
        c1 =  curve_frag_graph_.pFrags[i].front();
        c2 =  curve_frag_graph_.cFrags[i].front();

        //curve_frag_graph_.extract_fragment(c1);
        //curve_frag_graph_.extract_fragment(c2);
      }
      else {
        dbdet_edgel_chain_list_iter fit = curve_frag_graph_.cFrags[i].begin();
        c1 =  (*fit); fit++;
        c2 =  (*fit);

        //add the second one to the first one and delete it from the graph
        //curve_frag_graph_.extract_fragment(c1);
        //curve_frag_graph_.extract_fragment(c2);

        //reverse the sequence of edgels
        vcl_reverse(c1->edgels.begin(), c1->edgels.end());
      }
      
      //geometric test 
      dbdet_edgel* e1 = c1->edgels[c1->edgels.size()-2];
      dbdet_edgel* e2 = c1->edgels.back();
      dbdet_edgel* e3 = c2->edgels.front();
      dbdet_edgel* e4 = c2->edgels[1];

      double dx1 = e2->pt.x()-e1->pt.x();
      double dy1 = e2->pt.y()-e1->pt.y();
      double dx2 = e4->pt.x()-e3->pt.x();
      double dy2 = e4->pt.y()-e3->pt.y();

      if (((dx1*dx2 + dy1*dy2)/vcl_sqrt(dx1*dx1+dy1*dy1)/vcl_sqrt(dx2*dx2+dy2*dy2))>SM_TH){ 
	curve_frag_graph_.extract_fragment(c1);
        curve_frag_graph_.extract_fragment(c2);
        c1->append(c2->edgels);
        curve_frag_graph_.insert_fragment(c1);
        //delete c2;
      }
      else { //not consistent so just put them back
        // reverse the changed edges order back
        if (curve_frag_graph_.pFrags[i].size()>1){
		vcl_reverse(c2->edgels.begin(), c2->edgels.end());
	}
        else if (curve_frag_graph_.cFrags[i].size()>1){
		vcl_reverse(c1->edgels.begin(), c1->edgels.end());
	}
        //curve_frag_graph_.insert_fragment(c1);
        //curve_frag_graph_.insert_fragment(c2);
      }
     }

    //degree 3 is a junction (T-junction or Y-junction)
    if (deg>2)
    {
      //goal is to see if any two will produce smooth continuation

      //get the standard setup first and then analyze

    }
}
    vcl_cout<<"Finish correcting the CFG topology"<<vcl_endl;
    // By Yuliang Aug/11/2010
    // degree 1 is end points
    // Here I solve the overlaping problem after merging 2 fragments and dealing with junction
    // I also mark where the junction is and the next step is to save the junction into a specific data structure
 
 /*for (unsigned i=0; i<edgemap_->edgels.size(); i++)
  {
    dbdet_edgel_chain *c1=0, *c2=0, *c3=0;
    dbdet_edgel* eA = edgemap_->edgels[i];

    int deg = curve_frag_graph_.pFrags[i].size()+ curve_frag_graph_.cFrags[i].size();
    if (deg==1){ //end point

      if(curve_frag_graph_.cFrags[i].size()==1){ // if child fragment from eA

        dbdet_edgel_chain_list_iter fit = curve_frag_graph_.cFrags[i].begin();
        c1 = (*fit);
        bool is_eA_on_c2 =false;
        int j = 1;
        for(;j!=(c1->edgels.size()-2);j++)
           {
            dbdet_edgel* eB = c1->edgels[j];
            int deg2 = curve_frag_graph_.pFrags[eB->id].size()+ curve_frag_graph_.cFrags[eB->id].size();

            if(deg2!=1) // point (other than endpoints of c1) is not endpoint of other curve fragment
                continue;
            else{ // point (other than endpoints of c1) is endpoint of other curve fragment

                 if(curve_frag_graph_.cFrags[eB->id].size()==1){ // if it is a child fragment c2 from eB
                    dbdet_edgel_chain_list_iter fit2 = curve_frag_graph_.cFrags[eB->id].begin();
                    c2 = (*fit2);
                    int k=1;

                    for(;k!=c2->edgels.size()-1;k++){ 
                        if (((c2->edgels[k]->id) == i)&&(k==j)) {// check whether eA is on c2 and whether 
                                                                             // it is overlaping fragment
                             is_eA_on_c2=true;
                             break;
                           }
                        else{
                             continue;
                            } 
                       }
                    if (is_eA_on_c2){ // if eA is on c2, there is a overlaping fragment eA to eB
                       curve_frag_graph_.extract_fragment(c1);
                       curve_frag_graph_.extract_fragment(c2);
                       vcl_reverse(c1->edgels.begin(), c1->edgels.end());
                       int sizeofchain=c2->edgels.size();
                       for (unsigned l=j; l<=(sizeofchain-1); l++)
                            c1->edgels.push_back(c2->edgels[l]);

                       curve_frag_graph_.insert_fragment(c1);
                       delete c2;
                       break;
                       }  
                    else{ // take it as a junction: c2 intersept c1 on eB
                       continue;
                        }
                        
                   }
               else{ // if it is a parent fragment to eB
                    dbdet_edgel_chain_list_iter fit2 = curve_frag_graph_.pFrags[eB->id].begin();
                    c2 = (*fit2);
                    int k=c2->edgels.size()-2;

                    for(;k!=0;k--){ 
                        if (((c2->edgels[k]->id) == i)&&((k+j)==(c2->edgels.size()-1))) {// check whether eA is on c2 and whether 
                                                                             // it is overlaping fragment
                             is_eA_on_c2=true;
                             break;
                           }
                        else{
                             continue;
                            } 
                       }
                    if (is_eA_on_c2){ // if eA is on c2, there is a overlaping fragment eA to eB
                       curve_frag_graph_.extract_fragment(c1);
                       curve_frag_graph_.extract_fragment(c2);
                       int sizeofchain=c1->edgels.size();
                       for (unsigned l=j; l<=(sizeofchain-1); l++)
                            c2->edgels.push_back(c1->edgels[l]);

                       curve_frag_graph_.insert_fragment(c2);
                       delete c1;
                       break;
                       }  
                    else{ // take it as a junction: c2 intersept c1 on eB
                       continue;
                        }
                      
                   }
                }
            }             
      }
      else{ // if parent fragment to eA

        dbdet_edgel_chain_list_iter fit = curve_frag_graph_.pFrags[i].begin();
        c1 = (*fit);
        bool is_eA_on_c2 =false;
        int j = (c1->edgels.size()-2);
        for(;j!=1;j--)
           {
            dbdet_edgel* eB = c1->edgels[j];
            int deg2 = curve_frag_graph_.pFrags[eB->id].size()+ curve_frag_graph_.cFrags[eB->id].size();

            if(deg2!=1) // point (other than endpoints of c1) is not endpoint of other curve fragment
                continue;
            else{ // point (other than endpoints of c1) is endpoint of other curve fragment

                 if(curve_frag_graph_.cFrags[eB->id].size()==1){ // if it is a child fragment c2 from eB
                    dbdet_edgel_chain_list_iter fit2 = curve_frag_graph_.cFrags[eB->id].begin();
                    c2 = (*fit2);
                    int k=1;

                    for(;k!=c2->edgels.size()-1;k++){ 
                        if (((c2->edgels[k]->id) == i)&&((k+j)==(c1->edgels.size()-1))) {// check whether eA is on c2 and whether 
                                                                             // it is overlaping fragment
                             is_eA_on_c2=true;
                             break;
                           }
                        else{
                             continue;
                            } 
                       }
                    if (is_eA_on_c2){ // if eA is on c2, there is a overlaping fragment eA to eB
                       curve_frag_graph_.extract_fragment(c1);
                       curve_frag_graph_.extract_fragment(c2);
                       int sizeofchain=c2->edgels.size();
                       for (unsigned l=(k+1); l<(sizeofchain-1); l++)
                            c1->edgels.push_back(c2->edgels[l]);

                       curve_frag_graph_.insert_fragment(c1);
                       delete c2;
                       break;
                       }  
                    else{ // take it as a junction: c2 intersept c1 on eB
                       continue;
                        }
                        
                   }
               else{ // if it is a parent fragment to eB
                    dbdet_edgel_chain_list_iter fit2 = curve_frag_graph_.pFrags[eB->id].begin();
                    c2 = (*fit2);
                    int k=(c2->edgels.size()-2);

                    for(;k!=0;k--){ 
                        if (((c2->edgels[k]->id) == i)&&((c1->edgels.size()-j)==(c2->edgels.size()-k))) {// check whether eA is on c2 and whether 
                                                                             // it is overlaping fragment
                             is_eA_on_c2=true;
                             break;
                           }
                        else{
                             continue;
                            } 
                       }
                    if (is_eA_on_c2){ // if eA is on c2, there is a overlaping fragment eA to eB
                       curve_frag_graph_.extract_fragment(c1);
                       curve_frag_graph_.extract_fragment(c2);
                       vcl_reverse(c1->edgels.begin(), c1->edgels.end());
                       int sizeofchain=c1->edgels.size();
                       for (unsigned l=(c1->edgels.size()-j); l<(sizeofchain-1); l++)
                            c2->edgels.push_back(c1->edgels[l]);

                       curve_frag_graph_.insert_fragment(c2);
                       delete c1;
                       break;
                       }  
                    else{ // take it as a junction: c2 intersept c1 on eB
                       continue;
                        }
                      
                   }
                }
            }
                       
      }
    }

  }*/
  


}




