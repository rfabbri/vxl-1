// This is brcv/seg/dbdet/pro/dbdet_contour_tracer_process.cxx

//:
// \file

#include "dbdet_contour_tracer_process.h"
#include <dbdet/tracer/dbdet_contour_tracer.h>

#include <vidpro1/storage/vidpro1_image_storage.h>
#include <vidpro1/storage/vidpro1_vsol2D_storage.h>
#include <vidpro1/storage/vidpro1_vsol2D_storage_sptr.h>

#include <vcl_vector.h>
#include <vcl_string.h>
#include <vil/vil_image_resource.h>
#include <vil/vil_new.h>
#include <vil/vil_image_view.h>
#include <vil/vil_convert.h>
#include <vil/vil_math.h>
#include <vil/algo/vil_threshold.h>

#include <vsol/vsol_polygon_2d.h>
#include <vsol/vsol_polygon_2d_sptr.h>
#include <vsol/vsol_point_2d.h>
#include <vsol/vsol_point_2d_sptr.h>

#include <dbsol/algo/dbsol_curve_algs.h>

//: Constructor
dbdet_contour_tracer_process::dbdet_contour_tracer_process()
{
  if( !parameters()->add( "Smoothing Sigma" , "-sigma"     , 1.0f ) ||
      !parameters()->add( "Curvature smoothing # of steps", "-nsteps" , 1) || 
      !parameters()->add( "Curvature smoothing beta"   , "-beta" , 0.3f ) ||
      !parameters()->add( "Threshold to create binary image [0-255], -1 for automatic"   , "-intensity_threshold" , (int)-1 ) ||
      !parameters()->add( "length threshold"   , "-len_threshold" , (int)20 ) ||
      !parameters()->add( "subsample_contour"   , "-bSub_con" , false) ||
      !parameters()->add( "Subsample Smartly"   , "-bSmart" , false ) ||
      !parameters()->add( "c_ds"   , "-c_ds" , (double) 1.0) ||
      !parameters()->add( "perform_area_normalization" , "-perform_area_normalization" , false) ||
      !parameters()->add( "desired_area" , "-desired_area" , (double) 3448.0))
  {
    vcl_cerr << "ERROR: Adding parameters in " __FILE__ << vcl_endl;
  }
}


//: Destructor
dbdet_contour_tracer_process::~dbdet_contour_tracer_process()
{
}


//: Clone the process
bpro1_process*
dbdet_contour_tracer_process::clone() const
{
  return new dbdet_contour_tracer_process(*this);
}


//: Return the name of this process
vcl_string
dbdet_contour_tracer_process::name()
{
  return "Contour Tracer";
}


//: Return the number of input frame for this process
int
dbdet_contour_tracer_process::input_frames()
{
  return 1;
}


//: Return the number of output frames for this process
int
dbdet_contour_tracer_process::output_frames()
{
  return 1;
}


//: Provide a vector of required input types
vcl_vector< vcl_string > dbdet_contour_tracer_process::get_input_type()
{
  vcl_vector< vcl_string > to_return;
  to_return.push_back( "image" );
  return to_return;
}


//: Provide a vector of output types
vcl_vector< vcl_string > dbdet_contour_tracer_process::get_output_type()
{
  vcl_vector<vcl_string > to_return;
  to_return.push_back( "vsol2D" );
  return to_return;
}


//: Execute the process
bool
dbdet_contour_tracer_process::execute()
{
  if ( input_data_.size() != 1 ){
    vcl_cout << "In dbdet_contour_tracer_process::execute() - not exactly one"
             << " input images \n";
    return false;
  }
  clear_output();

  //get the tracing parameters
  float sigma=0, beta=0;
  int nsteps=0, threshold=0;
  int intensity_threshold = 127;
  bool bSub_con=true, bSmart=true, areaNorm=false;
  double c_ds = 1.0, desiredArea=3448.0;

  parameters()->get_value( "-sigma", sigma);
  parameters()->get_value( "-nsteps", nsteps );
  parameters()->get_value( "-beta", beta );
  parameters()->get_value( "-len_threshold", threshold );
  parameters()->get_value( "-intensity_threshold", intensity_threshold );

  parameters()->get_value( "-bSub_con", bSub_con );
  parameters()->get_value( "-bSmart", bSmart );
  parameters()->get_value( "-perform_area_normalization", areaNorm);
  parameters()->get_value( "-c_ds", c_ds );
  parameters()->get_value( "-desired_area", desiredArea);

  // get binary image from the storage class
  vidpro1_image_storage_sptr frame_image;
  frame_image.vertical_cast(input_data_[0][0]);

  vil_image_resource_sptr image_sptr = frame_image->get_image();
  vil_image_view<bool> binary_img;

  // no conversion necessary when input is binary image
  if (image_sptr->pixel_format()==binary_img.pixel_format() && 
    image_sptr->nplanes() == 1)
  {
    binary_img = image_sptr->get_view();
  }
  else
  {
    // get the grey view
    vil_image_view<vxl_byte> image;  
    if (image_sptr->nplanes()==1)
    {
      image = *vil_convert_cast(vxl_byte(), image_sptr->get_view());
    }
    else
    {
      image = *vil_convert_cast(vxl_byte(), 
      vil_convert_to_grey_using_rgb_weighting(image_sptr->get_view()));
    }

    // threshold the image to make sure that it is binary
    vxl_byte threshold_value = 128;
    if (intensity_threshold == -1)
    {
      vxl_byte min_value = 0, max_value = 0;
      vil_math_value_range(image, min_value, max_value);
      threshold_value = (min_value+max_value)/2;
    }
    else if (0<=intensity_threshold && intensity_threshold<=255)
    {
      threshold_value = (vxl_byte)(intensity_threshold);
    }
    vil_threshold_above<vxl_byte >(image, binary_img, threshold_value);
  }

  
  
  //invoke the tracer
  dbdet_contour_tracer ctracer;
  ctracer.set_sigma(sigma);
  ctracer.set_curvature_smooth_nsteps(nsteps);
  ctracer.set_curvature_smooth_beta(beta);
  ctracer.trace(binary_img);
  
  //get the interesting contours
  vcl_vector< vsol_spatial_object_2d_sptr > contours;
  
  for (unsigned i=0; i<ctracer.contours().size(); i++)
  {
    if (threshold<3) threshold=3;

    if ((int)(ctracer.contours()[i].size()) >= threshold)
    {
      vsol_polygon_2d_sptr newContour = new vsol_polygon_2d (ctracer.contours()[i]);//ctracer.largest_contour()

      if (bSub_con){
        if (bSmart)
          newContour = dbsol_subsample_contour_smart(newContour, c_ds);
        else
          newContour = dbsol_subsample_contour(newContour, c_ds);
      }

      // If area normalization is desired on the contours, equalize all the contour areas to the provided value
      if(areaNorm)
      {
          double normFactor = vcl_sqrt(desiredArea/newContour->area());
          vsol_point_2d_sptr cent = newContour->centroid();
          double centroid_x = cent->x();
          double centroid_y = cent->y();

          int numPoints = newContour->size();

          for(int i=0; i<numPoints; ++i)
          {
              vsol_point_2d_sptr cur_vertex = newContour->vertex(i);
              double cur_x = cur_vertex->x();
              double cur_y = cur_vertex->y();
              cur_vertex->set_x((normFactor*(cur_x-centroid_x))+centroid_x);
              cur_vertex->set_y((normFactor*(cur_y-centroid_y))+centroid_y);
          }
      }


      contours.push_back(newContour->cast_to_spatial_object());
    }
  }

  // create the output storage class
  vidpro1_vsol2D_storage_sptr output_vsol = vidpro1_vsol2D_storage_new();
  output_vsol->add_objects(contours, "trace");
  output_data_[0].push_back(output_vsol);
  
  return true;
}

bool
dbdet_contour_tracer_process::finish()
{
  return true;
}

