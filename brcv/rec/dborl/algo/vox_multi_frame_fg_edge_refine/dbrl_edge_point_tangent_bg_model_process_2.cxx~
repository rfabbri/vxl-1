// This is pro/dbrl_edge_point_tangent_bg_model_process_2.cxx

//:
// \file
#include "dbrl_edge_point_tangent_bg_model_process_2.h"
#include <dbbgm/pro/dbbgm_distribution_image_storage.h>
#include <bpro1/bpro1_parameters.h>
#include <vidpro1/storage/vidpro1_image_storage.h>
#include <vidpro1/storage/vidpro1_image_storage_sptr.h>
#include <vidpro1/vidpro1_repository.h>
#include <dbbgm/dbbgm_distribution_image.h>
#include <dbbgm/dbbgm_update.h>

#include <dbsta/dbsta_gaussian_indep.h>
#include <dbsta/dbsta_detector_gaussian.h>
#include <dbsta/dbsta_detector_mixture.h>
#include <dbsta/dbsta_basic_functors.h>
#include <dbsta/dbsta_functor_sptr.h>
#include <dbsta/algo/dbsta_adaptive_updater.h>
#include <vnl/vnl_matrix.h>
#include <vil/vil_image_resource.h>
#include <vil/vil_image_view.h>
#include <vil/vil_convert.h>
#include <vil/vil_new.h>
#include <vil/vil_math.h>
#include <vil/vil_plane.h>
#include <vil/algo/vil_gauss_filter.h>
#include <vul/vul_timer.h>

#include <bvis1/bvis1_manager.h>

//: Constructor
dbrl_edge_point_tangent_bg_model_process_2::dbrl_edge_point_tangent_bg_model_process_2(): model_(NULL)
{

    if( !parameters()->add( "Max Num Components" ,   "-maxcmp" ,  unsigned(3) ) ||
	!parameters()->add( "Initial Variance"   ,   "-initv" ,   1.0f       ) ||
	!parameters()->add( "Initial Weight"     ,   "-initw" ,   0.1f        ) ||
	!parameters()->add( "Use automated sliding windows scheme" , "-autbg" , true))
    {
	vcl_cerr << "ERROR: Adding parameters in " __FILE__<< vcl_endl;
    }

}

//: Destructor
dbrl_edge_point_tangent_bg_model_process_2::~dbrl_edge_point_tangent_bg_model_process_2()
{
   
}


//: Return the name of this process
vcl_string
dbrl_edge_point_tangent_bg_model_process_2::name()
{
    return "subpixel edge point tangent BG model builder";
}


//: Return the number of input frame for this process
int
dbrl_edge_point_tangent_bg_model_process_2::input_frames()
{
    return 1;
}


//: Return the number of output frames for this process
int
dbrl_edge_point_tangent_bg_model_process_2::output_frames()
{
    return 1;
}


//: Provide a vector of required input types
vcl_vector< vcl_string > dbrl_edge_point_tangent_bg_model_process_2::get_input_type()
{
    vcl_vector< vcl_string > to_return;
    
    bool auto_bg;
    parameters()->get_value( "-autbg"  ,  auto_bg );

    to_return.push_back( "image" );

    if(!auto_bg)
	to_return.push_back( "dbbgm_distribution_image" );

    return to_return;
}


//: Provide a vector of output types
vcl_vector< vcl_string > dbrl_edge_point_tangent_bg_model_process_2::get_output_type()
{  
    vcl_vector<vcl_string > to_return;
    
    bool auto_bg;
    parameters()->get_value( "-autbg"  ,  auto_bg );

    if(auto_bg)
	to_return.push_back( "dbbgm_distribution_image" );
    
    return to_return;
}


//: Execute the process
bool
dbrl_edge_point_tangent_bg_model_process_2::execute()
{
    if ( input_data_.size() != 1 )
    {
	vcl_cout << "In dbbgm_model_process::execute() - "
		 << "not exactly two input images \n";
	return false;
    }
    clear_output();
    // get the process parameters 
    //unused float sigma = 0.0f, 
    float init_weight = 0.0f, init_var = 0.0f;
    unsigned int max_components=0; // window_size=0;
    bool auto_bg;
    parameters()->get_value( "-maxcmp" ,  max_components );
    parameters()->get_value( "-initw"  ,  init_weight );
    parameters()->get_value( "-initv"  ,  init_var );
    parameters()->get_value( "-autbg"  ,  auto_bg );
  

    //: assuming for no edge the direction is 255.

    if(!auto_bg)
    {
	// get image from the storage class
	vidpro1_image_storage_sptr edge_image;
	vidpro1_image_storage_sptr edge_image_dir;
	edge_image_dir.vertical_cast(input_data_[0][0]);
	vil_image_resource_sptr edge_image_dir_rsc = edge_image_dir->get_image();
	vil_image_view<float> edgedirimg = edge_image_dir_rsc->get_view(0,edge_image_dir_rsc->ni(),0,edge_image_dir_rsc->nj());


	dbsta_gaussian_indep<float,1> init_gauss(vnl_vector_fixed<float,1>(0.0f),vnl_vector_fixed<float,1>(init_var) );
	init_gauss.set_data(dbsta_stats_data<float>(1));                                  
	dbsta_mg_window_updater<float> updater(init_gauss, max_components);

	dbbgm_distribution_image_storage_sptr frame_distimg;
	frame_distimg.vertical_cast(input_data_[0][1]);

	if(!frame_distimg)
	{
	    dbsta_mixture<float> mixture;
	    mixture.set_data(dbsta_stats_data<float>(0));
	    model_ = new dbbgm_distribution_image<float>(edgedirimg.ni(),edgedirimg.nj(),mixture);
	    frame_distimg = dbbgm_distribution_image_storage_new(model_);
	    frame_distimg->mark_global();
	    input_data_[0][1] = frame_distimg;
	}
	else
	{
	    model_ = frame_distimg->dist_image();
	    // This marks the data as modified so the GUI will redraw
	    output_data_[0].push_back(frame_distimg);
	}
	dbbgm_distribution_image<float> *model = static_cast<dbbgm_distribution_image<float>*>(model_.ptr());
	if(edgedirimg.nplanes()==3)
	{
	    vil_image_view<float> currplane=vil_plane(edgedirimg,2);
	    update(*model,currplane,updater,-200.0f);
	}
	return true;
    }
    else
    {
	//sequence of images to be used for building the background
	//numbers are relative to the frame for which foreground will be extracted
	//omitting the first one, which is -10
	int seq[7] = {10, -20, 20, -5, 5, -17, 17};
	//int seq[7] = {1, -2, 2, -5, 5, -7, 7};

	//get the initialization image from image -10
	//vidpro1_repository_sptr repo = bvis1_manager::instance()->repository();
	vidpro1_image_storage_sptr edge_image_dir;

	edge_image_dir.vertical_cast(input_data_[0][20]);
	if(!edge_image_dir)
	{
	    vcl_cerr << "ERROR: Cannot find the edge image - make sure you use the appropriate converter tools on the edge maps!" << vcl_endl;
	    vcl_cout << "Returning false" << vcl_endl;
	    return false;
	}

	vil_image_resource_sptr edge_image_dir_rsc = edge_image_dir->get_image();
	vil_image_view<float> edgedirimg = edge_image_dir_rsc->get_view(0,edge_image_dir_rsc->ni(),0,edge_image_dir_rsc->nj());

	//initialize mixture of gaussians

	dbsta_gaussian_indep<float,1> init_gauss(vnl_vector_fixed<float,1>(0.0f),vnl_vector_fixed<float,1>(init_var) );
	init_gauss.set_data(dbsta_stats_data<float>(1));                                  
	dbsta_mg_window_updater<float> updater(init_gauss, max_components);

	dbbgm_distribution_image_storage_sptr frame_distimg;

	dbsta_mixture<float> mixture;
	mixture.set_data(dbsta_stats_data<float>(0));
	model_ = new dbbgm_distribution_image<float>(edgedirimg.ni(),edgedirimg.nj(),mixture);
	frame_distimg = dbbgm_distribution_image_storage_new(model_);

	dbbgm_distribution_image<float> *model = static_cast<dbbgm_distribution_image<float>*>(model_.ptr());
    if(edgedirimg.nplanes()==3)
    {
	vil_image_view<float> currplane=vil_plane(edgedirimg,2);
	update(*model,currplane,updater,-200.0f);
    }

    //loop over all the rest of the training images to keep updating the model
    for(unsigned i=0; i<7; ++i)
    {
	vidpro1_image_storage_sptr edge_image_dir_current;
	edge_image_dir_current.vertical_cast(input_data_[0][(20+seq[i])]);
	if(!edge_image_dir_current)
	{
	    vcl_cerr << "ERROR: Cannot find the edge image - make sure you use the appropriate converter tools on the edge maps!" << vcl_endl;
	    vcl_cout << "Returning false" << vcl_endl;
	    return false;
	}
	vil_image_resource_sptr edge_image_dir_rsc_current = edge_image_dir_current->get_image();
	vil_image_view<float> edgedirimg_current = edge_image_dir_rsc_current->get_view(0,edge_image_dir_rsc_current->ni(),0,edge_image_dir_rsc_current->nj());

	//dbbgm_distribution_image<float> *model = static_cast<dbbgm_distribution_image<float>*>(model_.ptr());
	if(edgedirimg_current.nplanes()==3)
	{
	    vil_image_view<float> currplane=vil_plane(edgedirimg_current,2);
	    update(*model,currplane,updater,-200.0f);
	}
    }

    output_data_[0].push_back(frame_distimg);
    bvis1_manager::instance()->display_current_frame();
    return true;
}


}
//: Clone the process
bpro1_process*
dbrl_edge_point_tangent_bg_model_process_2::clone() const
{
    return new dbrl_edge_point_tangent_bg_model_process_2(*this);
}

bool
dbrl_edge_point_tangent_bg_model_process_2::finish()
{

  
    return true;
}

