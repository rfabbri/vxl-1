//:
// \file
// \author Maruthi Narayanan (mn@lems.brown.edu)
// \date 05/08/08
//
//        An algorithm to run edge detection and linking algorithms on images, 
//        input object is a single image, output is an edge map or a 
//        boundary fragment map, with an option to associate to the image or 
//        to write to the object folder
//      
// \verbatim
//   Modifications
//  
// \endverbatim

//
//

#include "dborl_edge_det_link_params.h"
#include "dborl_edge_det_link_params_sptr.h"

#include <vcl_iostream.h>
#include <vul/vul_file.h>
#include <vil/vil_image_resource_sptr.h>
#include <vil/vil_load.h>
#include <dborl/algo/dborl_utilities.h>
#include <vul/vul_timer.h>

#include <vidpro1/storage/vidpro1_image_storage_sptr.h>
#include <vidpro1/storage/vidpro1_image_storage.h>
#include <vidpro1/process/vidpro1_save_cem_process.h>
#include <vidpro1/process/vidpro1_save_con_process.h>

#include <dbdet/pro/dbdet_third_order_edge_detector_process.h>
#include <dbdet/pro/dbdet_third_order_color_edge_detector_process.h>
#include <dbdet/pro/dbdet_sel_process.h>
#include <dbdet/pro/dbdet_sel_extract_contours_process.h>
#include <dbdet/pro/dbdet_contour_tracer_process.h>
#include <dbdet/pro/dbdet_prune_curves_process.h>
#include <dbdet/pro/dbdet_save_edg_process.h>
#include <dbdet/pro/dbdet_edgemap_storage.h>
#include <dbdet/pro/dbdet_save_cvlet_map_process.h>
#include <dbdet/pro/dbdet_load_edg_process.h>

int main(int argc, char *argv[]) {

    // Let time how long this takes
    // Start timer
    vul_timer t;

    dborl_edge_det_link_params_sptr params = 
        new dborl_edge_det_link_params("dborl_edge_det_link");  

    if (!params->parse_command_line_args(argc, argv))
        return 1;

    //: always print the params file if an executable to work with ORL web 
    // interface
    if (!params->print_params_xml(params->print_params_file()))
        vcl_cerr << "problems in writing params file to: " << 
            params->print_params_file() << vcl_endl;

    if (params->exit_with_no_processing() || params->print_params_only())
        return 0;

    //: always call this method to actually parse the input parameter file 
    // whose name is extracted from the command line
    if (!params->parse_input_xml())
        return 1;

    //load the input image
    vcl_string input_img = params->input_object_dir_() + "/" 
        + params->input_object_name_() + params->input_extension_();

    if (!vul_file::exists(input_img)) 
    {
        vcl_cerr << "Cannot find image: " << input_img << vcl_endl;
        return 1;
    }

    // Grab image
    vil_image_resource_sptr img_sptr = 
        vil_load_image_resource(input_img.c_str());
    if (!img_sptr) 
    {
        vcl_cerr << "Cannot load image: " << input_img << vcl_endl;
        return 1;
    }

    // Create vid pro storage
    vidpro1_image_storage_sptr inp = new vidpro1_image_storage();
    inp->set_image(img_sptr);

    // Lets trace out contours ignore everything else except for saving
    
    // Create storage
    vcl_vector<bpro1_storage_sptr> ct_results;
    if ( params->trace_contours_())
    {
        vcl_cout<<"************ Contour Tracing  ************"<<vcl_endl;

        dbdet_contour_tracer_process ct_pro;
        set_process_parameters_of_bpro1(*params, 
                                        ct_pro, 
                                        params->tag_contour_tracing_);
        
        // Before we start the process lets clean input output
        ct_pro.clear_input();
        ct_pro.clear_output();

        // Start the process sequence
        ct_pro.add_input(inp);
        bool ct_status = ct_pro.execute();
        ct_pro.finish();

        // Grab output from gray scale third order edge detection
        // if process did not fail
        if ( ct_status )
        {
            ct_results = ct_pro.get_output();
        }

        //Clean up after ourselves
        ct_pro.clear_input();
        ct_pro.clear_output();

        if (ct_results.size() != 1 )
        {
            vcl_cerr<< "Contour tracing failed"<<vcl_endl;
            return 1;
        }

    }

    //******************** Edge Detection ********************************
    // Perform third order edge detection if we are not tracing contours
    
    // Create output storage for edge detection
    vcl_vector<bpro1_storage_sptr> edge_det_results;
    
    if ( !params->trace_contours_())
    {
        vcl_cout<<"************ Edge Detection   ************"<<vcl_endl;
<<<<<<< .mine

        // First lets check if we are using existing edges
        if ( params->use_existing_edges_())
=======
        /*
        if (img_sptr->nplanes() != 3)
>>>>>>> .r15623
        {
<<<<<<< .mine
          
            //load the input edge file
            vcl_string input_edg_file = params->input_object_dir_() + "/" 
                + params->input_object_name_() + params->edge_extension_();
            
            if (!vul_file::exists(input_edg_file)) 
            {
                vcl_cerr << "Cannot find edge map: " << input_edg_file 
                         << vcl_endl;
                return 1;
            }
            vcl_cout<<"Using existing edge file "<<input_edg_file<<vcl_endl;
=======
        */
        
            dbdet_third_order_edge_detector_process pro_gray_edg;
            set_process_parameters_of_bpro1(*params, 
                                            pro_gray_edg, 
                                            params->tag_gray_edge_detection_);
>>>>>>> .r15623

            // Edge loader process
            dbdet_load_edg_process load_edg;
            
            bpro1_filepath input(input_edg_file,params->edge_extension_());

            load_edg.parameters()->set_value("-edginput",input);

            // Before we start the process lets clean input output
            load_edg.clear_input();
            load_edg.clear_output();

            // Pass in input vsol string
            bool load_edg_status = load_edg.execute();
            load_edg.finish();

            // Grab output from symbolic edge linking
            if ( load_edg_status )
            {
                edge_det_results = load_edg.get_output();
            }

            //Clean up after ourselves
            load_edg.clear_input();
            load_edg.clear_output();

<<<<<<< .mine
        }
        else
=======
            /* XXX rfabbri
        } 
        // Perform color third order edge detection
        else 
>>>>>>> .r15623
        {
            // Run the appropriate edge detector
            if (img_sptr->nplanes() != 3)
            {
        
                dbdet_third_order_edge_detector_process pro_gray_edg;
                set_process_parameters_of_bpro1
                    (*params, 
                     pro_gray_edg, 
                     params->tag_gray_edge_detection_);

                // Before we start the process lets clean input output
                pro_gray_edg.clear_input();
                pro_gray_edg.clear_output();

                // Start the process sequence
                pro_gray_edg.add_input(inp);
                bool to_g_status = pro_gray_edg.execute();
                pro_gray_edg.finish();

                // Grab output from gray scale third order edge detection
                // if process did not fail
                if ( to_g_status )
                {
                    edge_det_results = pro_gray_edg.get_output();
                }

                //Clean up after ourselves
                pro_gray_edg.clear_input();
                pro_gray_edg.clear_output();

            } 
            // Perform color third order edge detection
            else 
            {
 
                dbdet_third_order_color_edge_detector_process pro_color_edg;
                set_process_parameters_of_bpro1(*params, 
                                                pro_color_edg, 
                                                params->
                                                tag_color_edge_detection_);  

                // Before we start the process lets clean input output
                pro_color_edg.clear_input();
                pro_color_edg.clear_output();

                pro_color_edg.add_input(inp);
                bool to_c_status = pro_color_edg.execute();
                pro_color_edg.finish();

                // Grab output from color third order edge detection
                // if process did not fail
                if ( to_c_status )
                {
                    edge_det_results = pro_color_edg.get_output();
                }

                //Clean up after ourselves
                pro_color_edg.clear_input();
                pro_color_edg.clear_output();

            }
        }
<<<<<<< .mine

=======
        */
 
>>>>>>> .r15623
        if (edge_det_results.size() != 1 )
        {
            vcl_cerr<< "Process output does not contain an edge map"<<vcl_endl;
            return 1;
        
        }

    }

    //******************** Edge Linking *********************************
    // Perform sel linking if we are not doing contour tracing

    // Set up storage for sel results
    vcl_vector<bpro1_storage_sptr> sel_results;

    if ( !params->trace_contours_())
    {
        vcl_cout<<"************ Edge Linking     ************"<<vcl_endl;
        dbdet_sel_process sel_pro;
        set_process_parameters_of_bpro1(*params, 
                                        sel_pro, 
                                        params->tag_edge_linking_);  
    
        // Before we start the process lets clean input output
        sel_pro.clear_input();
        sel_pro.clear_output();

        // Use input from edge detection
        sel_pro.add_input(edge_det_results[0]);
        bool el_status = sel_pro.execute();
        sel_pro.finish();

        // Grab output from symbolic edge linking
        // if process did not fail
        if ( el_status )
        {
            sel_results = sel_pro.get_output();
        }

        //Clean up after ourselves
        sel_pro.clear_input();
        sel_pro.clear_output();

        if (sel_results.size() != 1) 
        {
            vcl_cerr << "Process output does not contain a sel data structure"
                     << vcl_endl;
            return 1;
        }

    }

    //******************** Extract Contours *********************************
    // Since contour tracer already produces vsol dont bother unless
    // we peformed edge detection and linking

    // create storage for ec results
    vcl_vector<bpro1_storage_sptr> ec_results;

    if ( !params->trace_contours_())
    {
        vcl_cout<<"************ Extract Contours ************"<<vcl_endl;

        // Converts a sel object to a vsol object
        dbdet_sel_extract_contours_process ec_pro;
        set_process_parameters_of_bpro1(*params, 
                                        ec_pro, 
                                        params->tag_extract_contours_);  

        // Before we start the process lets clean input output
        ec_pro.clear_input();
        ec_pro.clear_output();
    
        // Use input from symbolic edge linking
        ec_pro.add_input(sel_results[0]);
        bool ec_status = ec_pro.execute();
        ec_pro.finish();

        // Grab output from extraction of contours
        // if process does not fail
        if (ec_status)
        {
            ec_results = ec_pro.get_output();
        }

        //Clean up after ourselves
        ec_pro.clear_input();
        ec_pro.clear_output();

        //:get the output from edge detection   
        if (ec_results.size() != 1) 
        {
            vcl_cerr << "Process output does not contain a vsol structure"
                     << vcl_endl;

            return 1;
        }
    }

    //******************** Prune Contours *********************************
    // Prune contours based on contrast
    // Grab contours that remain after pruning
    vcl_vector<bpro1_storage_sptr> pc_results;
        
    if ( params->prune_contours_())
    {
        vcl_cout<<"************ Prune Contours   ************"<<vcl_endl;

        dbdet_prune_curves_process pc_pro;
        set_process_parameters_of_bpro1(*params, 
                                        pc_pro, 
                                        params->tag_prune_contours_);  
    
        // Before we start the process lets clean input output
        pc_pro.clear_input();
        pc_pro.clear_output();

        // Use input from vsol object
        if ( params->trace_contours_())
        {
            pc_pro.add_input(ct_results[0]);
        }
        else
        {
            pc_pro.add_input(ec_results[0]);
        }

        pc_pro.add_input(inp);
        bool pc_status = pc_pro.execute();
        pc_pro.finish();

        //:get the output from pruning curve fragments
        // if process does not fail
        if ( pc_status )
        {
            pc_results = pc_pro.get_output();
        }

        //Clean up after ourselves
        pc_pro.clear_input();
        pc_pro.clear_output();

        if (pc_results.size() != 1) 
        {
            vcl_cerr << "Process output does not contain a \
                         set of remaining contours after pruning"<<vcl_endl;
            return 1;
        }

    }


    //******************** Saving Section  *******************************
    // From this point forward, saving of edges, curvlets, contours

    //******************** Saving Edges  *********************************
    // save this edge map into a file

    // Though this would be dumb by a user to save edges when they 
    // have a contour, lets be prudent and make sure this is off
    if ( !params->trace_contours_())
    {
        if (params->save_edges_()) 
        {
            vcl_cout<<"************ Saving  Edges    ************"<<vcl_endl;

            dbdet_save_edg_process save_edg_pro;

            vcl_string output_file;
            if (params->save_to_object_folder_())
            { 
                output_file = params->output_edge_link_folder_() + "/";
            }
            else 
            {

                output_file = params->input_object_dir_() + "/";

            }
        
            if (!vul_file::exists(output_file)) 
            {
                vul_file::make_directory(output_file);

            }
    
            output_file = output_file + 
                params->input_object_name_();

            bool status(false);

            if ( params->edge_extension_() == ".edg" ||  params->edge_extension_() == ".edg.gz" )
            {                
                output_file = output_file + params->edge_extension_();
                bpro1_filepath output(output_file,params->edge_extension_());

                save_edg_pro.parameters()->set_value("-edgoutput",output);

                // Before we start the process lets clean input output
                save_edg_pro.clear_input();
                save_edg_pro.clear_output();

                save_edg_pro.add_input(edge_det_results[0]);
                status = save_edg_pro.execute();
                save_edg_pro.finish();

                //Clean up after ourselves
                save_edg_pro.clear_input();
                save_edg_pro.clear_output();

            }
            else
            {
                vcl_cerr<<"Unknown edge typ to save with"<<vcl_endl;
                
                //Set status to bad
                status = false;
            }
            if ( !status )
            {
        
                vcl_cerr << "Problems in saving edge file: " 
                         << output_file + params->edge_extension_()
                         << vcl_endl;
                return 1;
     
            }
        }
    }

   
    //******************** Save Curvelets  *********************************
    // Though this would be dumb by a user to save curvlet when they 
    // have a contour, lets be prudent and make sure this is off
    if ( !params->trace_contours_())
    {

        if ( params->save_curvelets_() )
        {

            vcl_cout<<"************ Saving Curvelets ************"<<vcl_endl;
            vcl_string output_cvlet_file;

            if (params->save_to_object_folder_())
            { 
                output_cvlet_file = params->output_edge_link_folder_() + "/";
            }
            else 
            {
                output_cvlet_file = params->input_object_dir_() + "/";
            }
        
            if (!vul_file::exists(output_cvlet_file)) 
            {
                vul_file::make_directory(output_cvlet_file);
        
            }
   
            output_cvlet_file = output_cvlet_file + 
                params->input_object_name_() +
                ".cvlet";
    
            bpro1_filepath output_cvlet(output_cvlet_file,
                                        ".cvlet");
    
            dbdet_save_cvlet_map_process save_cvlet_pro;
            save_cvlet_pro.parameters()->set_value("-cvlet_output",
                                                   output_cvlet);

            // Before we start the process lets clean input output
            save_cvlet_pro.clear_input();
            save_cvlet_pro.clear_output();

            // Kick of process
            save_cvlet_pro.add_input(sel_results[0]);
            bool write_cv_status = save_cvlet_pro.execute();
            save_cvlet_pro.finish();

            //Clean up after ourselves
            save_cvlet_pro.clear_input();
            save_cvlet_pro.clear_output();
        
            if ( !write_cv_status )
            {
        
                vcl_cerr << "Problems in saving .cvlet curvlet file: " 
                         << output_cvlet_file << vcl_endl;
                return 1;
     
            }

        }
    }
    //******************** Save Contours  *********************************
    vcl_cout<<"************ Saving Contours  ************"<<vcl_endl;

    vcl_string output_file;
    if (params->save_to_object_folder_())
    { 
        output_file = params->output_edge_link_folder_() + "/";
    }
    else 
    {
        output_file = params->input_object_dir_() + "/";
    }
        
    if (!vul_file::exists(output_file)) 
    {
        vul_file::make_directory(output_file);
        
    }
    
    output_file = output_file + params->input_object_name_();

    bool write_status(false);
    
    if ( params->trace_contours_() )
    {

        if ( params->output_extension_() == ".con" )
        {
            bpro1_filepath output(output_file,params->output_extension_());

            vidpro1_save_con_process save_con_pro;
            save_con_pro.parameters()->set_value("-conoutput",output);

            // Before we start the process lets clean input output
            save_con_pro.clear_input();
            save_con_pro.clear_output();

            // Kick of process
            save_con_pro.add_input(ct_results[0]);
            write_status = save_con_pro.execute();
            save_con_pro.finish();

            //Clean up after ourselves
            save_con_pro.clear_input();
            save_con_pro.clear_output();
        }
        else if ( params->output_extension_() == ".cem" ||
                  params->output_extension_() == ".cemv" || 
                  params->output_extension_() == ".cemv.gz")
        {
            output_file = output_file + params->output_extension_();
            bpro1_filepath output(output_file,params->output_extension_());

            // In this everything else, is .cem, .cemv , .cfg, etc
            vidpro1_save_cem_process save_cem_pro;
            save_cem_pro.parameters()->set_value("-cemoutput",output);

            // Before we start the process lets clean input output
            save_cem_pro.clear_input();
            save_cem_pro.clear_output();

            // Kick of process
            save_cem_pro.add_input(ct_results[0]);
            write_status = save_cem_pro.execute();
            save_cem_pro.finish();

            //Clean up after ourselves
            save_cem_pro.clear_input();
            save_cem_pro.clear_output();

        }
        else
        {

            // Unknown file extension encountered
            vcl_cerr<<"Unknow file extension " << params->output_extension_() 
              << " to save with OR ..."<<vcl_endl;
            vcl_cerr<<"Bad combination of inputs parameters  ..." <<vcl_endl;
            vcl_cerr<<"For example, saving output of sel with .con ext"
                    <<vcl_endl;

            // set write status to bad
            write_status=false;
 
        }
 
    }
    else if (params->output_extension_() == ".cem" ||
                params->output_extension_() == ".cemv" ||
                params->output_extension_() == ".cemv.gz")
    {

        output_file = output_file + params->output_extension_();
        bpro1_filepath output(output_file,params->output_extension_());

        // In this everything else, is .cem, .cemv , .cfg, etc
        vidpro1_save_cem_process save_cem_pro;
        save_cem_pro.parameters()->set_value("-cemoutput",output);

        // Before we start the process lets clean input output
        save_cem_pro.clear_input();
        save_cem_pro.clear_output();

   
        if ( params->prune_contours_() )
        {
            save_cem_pro.add_input(pc_results[0]);
        }
        else
        {
            save_cem_pro.add_input(ec_results[0]);

        }

        write_status = save_cem_pro.execute();
        save_cem_pro.finish();

        //Clean up after ourselves
        save_cem_pro.clear_input();
        save_cem_pro.clear_output();
    }
    else if (params->output_extension_() == ".cvlet")
    {
      vcl_cout << "Just outputting .cvlet, no contours.\n";
    }
    else 
    {
        // Unknown file extension encountered
        vcl_cerr<<"Unknow file extension " << params->output_extension_() 
          << " to save with OR ..."<<vcl_endl;
        vcl_cerr<<"Bad combination of inputs parameters  ..." <<vcl_endl;
        vcl_cerr<<"For example, saving output of sel with .con ext"<<vcl_endl;

        // set write status to bad
        write_status=false;
    }

    if ( !write_status )
    {
        
        vcl_cerr << "Problems in saving vsol contour file: " 
                 << output_file << vcl_endl;
        return 1;
     
    }

    double vox_time = t.real()/1000.0;
    t.mark();
    vcl_cout<<vcl_endl;
    vcl_cout<<"************ Time taken: "<<vox_time<<" sec"<<vcl_endl;

    // Just to be safe lets flush everything
    vcl_cerr.flush();
    vcl_cout.flush();

    //Success we made it this far
    return 0;
}

