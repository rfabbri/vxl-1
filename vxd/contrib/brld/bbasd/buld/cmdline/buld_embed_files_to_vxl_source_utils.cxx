// This is bbasd/buld/cmdline/buld_embed_files_to_vxl_source_utils.cxx

//:
// \file
// \brief
// \author Based on original code by  Firat Kalaycilar (@lems.brown.edu)
// \date Feb 09, 2010

#include<cstdlib>
#include<cstdio>
#include<iostream>
#include<sstream>
#include<fstream>
#include<vul/vul_file.h>

#include <buld/buld_random.h>

#include "buld_embed_files_to_vxl_source_utils.h"

std::string getRandomVariableName(int len)
{
    return std::string("var_") + buld_get_random_alphanumeric_string(len - 4);
}

std::string getRandomHFileTag(int len)
{
    return std::string("H_") + buld_get_random_alphanumeric_string(len - 4) + std::string("_H");
}

void parseInputFile(std::string& input_file_name, std::vector<std::string>& original_files, std::vector<std::string>& variable_names, std::string& root_path)
{
    std::ifstream fs(input_file_name.c_str());
    std::string line;
    std::stringstream ss(std::stringstream::in | std::stringstream::out);
    int number_of_entries = 0;
    int count = -2;
    if (fs.is_open())
    {
        do
        {
            getline (fs,line);
            if (count == -2)
            {
                ss << line;
                ss >> number_of_entries;
            }
            else if (count == -1)
            {
                root_path = line;
            }
            else
            {
                original_files.push_back(line);
                variable_names.push_back(getRandomVariableName(32));
            }
            count++;
        }
        while(number_of_entries > count);
    }
    fs.close();
}

int getArrayString(std::string filename, std::string& varname, std::string& array_string)
{
    std::FILE* pFile = fopen(filename.c_str(),"rb");
    array_string = "char " + varname + "[] = {";
    if (pFile)
    {
        std::fseek(pFile , 0 , SEEK_END);
        int lSize = std::ftell(pFile);
        std::rewind(pFile);

        // allocate memory to contain the whole file:
        char* buffer = (char*) std::malloc (sizeof(char)*lSize);
        if (buffer == NULL) {std::fputs ("Memory error",stderr); std::exit (2);}

        // copy the file into the buffer:
        int result = fread (buffer,1,lSize,pFile);
        if (result != lSize) {std::fputs ("Reading error",stderr); std::exit (3);}


        for(int i = 0; i < lSize; i++)
        {
            char temp[50];
            std::sprintf(temp, "%d", int(buffer[i]));
            array_string += std::string(temp);
            if (i != lSize-1)
                array_string += ",";
        }
        array_string += "};\n";
        // terminate
        std::fclose (pFile);
        std::free(buffer);
        return lSize;
    }
    else
        return -1;

}

void create_h_file(std::string& filename, std::string& h_file_tag, std::string& extract_command, std::string& delete_command)
{
    std::ofstream outs(filename.c_str());
    outs << "// GENERATED BY BULD\n\n#ifndef " << h_file_tag << std::endl << "#define " << h_file_tag << std::endl << std::endl;

    outs << "void " << extract_command << "(const char* dest_dir);" << std::endl;
    outs << "void " << delete_command << "(const char* dest_dir);" << std::endl;

    outs << std::endl << "#endif\n";
    outs.close();
}

void create_cpp_file(std::string& output_cpp_file_name, std::string& output_h_file_name, std::string& root_path, std::vector<std::string>& original_files, std::vector<std::string>& variable_names, std::vector<int>& data_sizes, std::string& extract_command, std::string& delete_command)
{
    std::ofstream outs(output_cpp_file_name.c_str());
    outs << "// GENERATED BY BULD\n\n#include \""<< vul_file::strip_directory(output_h_file_name) << "\"" << std::endl;
    outs << "#include<buld/buld_handle_files_embedded_in_vxl_source.h>" << std::endl;
    outs << "#include<string>" << std::endl;
    outs << "#include<vul/vul_file.h>" << std::endl;
    outs << "#include<ctime>" << std::endl << std::endl;

    for(int i = 0; i < original_files.size(); i++)
    {
        std::string array_string;
        data_sizes.push_back(getArrayString(root_path + std::string("/") + original_files[i], variable_names[i], array_string));
        if(data_sizes.back() != -1)
        {
            outs << array_string << std::endl;
        }
        else
        {
            std::fputs ("File not found",stderr); outs.close(); std::exit (4);
        }
    }
    outs << "void " << extract_command << "(const char* dest_dir)" << std::endl;
    outs << "{" << std::endl;
    outs << "   std::string expanded_path = vul_file::expand_tilde(dest_dir);" << std::endl;
    outs << "   if(!buld_is_file_extraction_in_progress(dest_dir))" << std::endl;
    outs << "   {" << std::endl;
    outs << "       if(!vul_file_exists(expanded_path))" << std::endl;
    outs << "       {" << std::endl;
    outs << "           vul_file::make_directory_path(expanded_path.c_str());" << std::endl;
    outs << "           buld_create_file_extraction_lock(dest_dir);" << std::endl;
    for(int i = 0; i < original_files.size(); i++)
    {
    outs << "           buld_default_extract_embedded_file(" << variable_names[i] << ", " << data_sizes[i] << ", dest_dir, \"" << original_files[i] << "\");" << std::endl;
    }
    outs << "           buld_remove_file_extraction_lock(dest_dir);" << std::endl;
    outs << "       }" << std::endl;
    outs << "   }" << std::endl;
    outs << "   else while(buld_is_file_extraction_in_progress(dest_dir))" << std::endl;
    outs << "   {" << std::endl;
    outs << "       std::clock_t endwait;" << std::endl;
    outs << "       endwait = std::clock () + 0.02 * CLOCKS_PER_SEC;" << std::endl;
    outs << "       while (std::clock() < endwait);" << std::endl;
    outs << "   }" << std::endl;
    outs << "}" << std::endl << std::endl;

    outs << "void " << delete_command << "(const char* dest_dir)" << std::endl;
    outs << "{" << std::endl;
    outs << "       buld_default_delete_extracted_file(dest_dir);" << std::endl;
    outs << "}" << std::endl;

    outs.close();
}
