//:
// \file
// \program to extract extrema responses of images
// \author Brandon Mayer
// \date 14 May 09
//

#include"bmvr_functions.h"

#include<brip/brip_vil_float_ops.h> //fast extrema method

#include<bsta/bsta_histogram.h> //histogram class

#include<vcl_iostream.h> //cout etc...
#include<vcl_fstream.h> //write file output
#include<vcl_string.h> // std::string
#include<vcl_vector.h> // this is the vector container from stl
#include<vcl_map.h> //for the stl map container ( (key, value) pair)
#include<vcl_utility.h> // for vcl_pair::make_pair

#include<vil/vil_convert.h> //to convert images to and from vxl_byte and float
#include<vil/vil_image_view.h> //image views
#include<vil/vil_load.h> //load images
#include<vil/vil_math.h> //image math functions
#include<vil/vil_save.h> //save images



#include<vnl/vnl_vector.h> //vector to create the histogram

#include<vul/vul_file_iterator.h> //file iterator to parse files
#include<vul/vul_file.h> //strip extension from directory

using namespace std;

int main(int argc, char *argv[])
{
    vcl_string imageDir = "/media/DATAPART1/BrandonDataFolder/VehicleRecognition/NormalizedImages/",
               gtMaskDir = "/media/DATAPART1/BrandonDataFolder/VehicleRecognition/GroundTruthMasks/",
               opOutDir = "/media/DATAPART1/BrandonDataFolder/VehicleRecognition/OperatorOutput/";

    
    // img.first = filename, img.second = vil_image_view pointer.
    vcl_map<vcl_string,vil_image_view<vxl_byte> > gtTemp;
    vcl_map<vcl_string,vil_image_view<bool> > gt;
    vcl_map<vcl_string,vil_image_view<float> > img, opOut;
    
    
    // load images
    vcl_string imgDir = imageDir + "*.png";
    for(vul_file_iterator fn = imgDir; fn; ++fn)
    {
        vcl_string filename = vul_file::strip_directory(fn());
        filename = vul_file::strip_extension(filename);
        vcl_cout << "Loading Image: " << filename << "\n";
        //img[filename] = vil_load( fn() );
        //load in and convert to float type so we may apply extrema operator
        img.insert(vcl_make_pair(filename,vil_convert_cast(float(),vil_load(fn()))));
        
    }

    // load ground truths
    vcl_string gtDir = gtMaskDir + "*.png";
    for(vul_file_iterator fn = gtDir; fn; ++fn)
    {
        bool minb,maxb;
        vxl_byte min,max;
        vcl_string filename = vul_file::strip_directory(fn());
        filename = vul_file::strip_extension(filename);
        vcl_cout << "Loading Ground Truth: " << filename << "\n";
        //gt.insert(vcl_make_pair(filename,vil_convert_cast(bool(),vil_load(fn()))));
        gtTemp.insert(vcl_make_pair(filename,vil_load(fn())));
        bmvr_functions::checkBinary(vcl_cout,gtTemp[filename]);
        //gt.set_size(gtTemp.ni(),gtTemp.nj(),gtTemp.nplanes());
        
        vil_math_value_range(gt[filename],minb,maxb);
        vcl_cout << "gt range: min = " << static_cast<int>(minb) << " , max = " << static_cast<int>(maxb) 
                 << vcl_endl << vcl_endl;
    }

    //iterate through the loaded images
    for( vcl_map<vcl_string,vil_image_view<float> >::iterator it = img.begin();
         it != img.end(); ++it)
    {
        vcl_string currImg = it->first;
        unsigned ni = it->second.ni(),
                 nj = it->second.nj(),
                 nplanes = it->second.nplanes();
        //create an empty image of appropriate size
        vil_image_view<float> temp(ni,nj,nplanes);
        vcl_cout << "ni = " << ni << ", nj = " << nj << ", nplanes = " << nplanes << vcl_endl;
        opOut.insert(vcl_make_pair(currImg,temp));

       // apply extream operator to image
       vcl_cout << "Applying Extrema operator to image "<< currImg  << "..." <<vcl_endl;
       bool bright = true; //just to remind myself i'm looking for either bright or dark cars
       opOut[currImg] = brip_vil_float_ops::fast_extrema(img[currImg],2,1,-45,bright);

       //write operator response to disk
       //vil_image_view<vxl_byte> imgByte = *vil_convert_round(vxl_byte(),opOut);
       //vcl_string outName = opOutDir + currImg + ".png";
       //vil_save(imgByte,outName.c_str());

       // if the current image is an image for which we have a ground truth, calculate the 
       // distribution of operator response for that image
       if(currImg=="normalized0"||currImg=="normalized1"||currImg=="normalized3"||currImg=="normalized4"||
          currImg=="normalized6"||currImg=="normalized10"||currImg=="normalized16")
       {
           vcl_string gtName = currImg+"_gt";
           vcl_cout << "Creating ground truth histogram of operator response for image " << currImg << "..." <<"\n";
           vil_image_view<float>::iterator it = opOut[currImg].begin();
           vil_image_view<float>::iterator itEnd = opOut[currImg].end();
           unsigned nbins = 100; // arbitrarily set.
           float min,max;
           // get the range of the current operator response to set up histogram
           vil_math_value_range(opOut[currImg],min,max);
           min = 0.0; //we'll just start the histogram from 0 regardless of true min
           

           vcl_cout << "Max operator response = " << max << vcl_endl;
               
           // make the histogram object
           bsta_histogram<float> hist(min,max,nbins);
           vcl_string temp = opOutDir+currImg+".txt";
           vcl_ofstream ofst(temp.c_str(),vcl_ios_out);
           for(unsigned i = 0; i < ni; ++i)
              for(unsigned j = 0; j < nj; ++j)
                  if(gt[gtName](i,j)==1)
                  {
                     hist.upcount(opOut[currImg](i,j),1);
                     ofst << opOut[currImg](i,j) << ", ";
                  }
                  
              
           
           // write the histogram to disk
           vcl_string outName = opOutDir+currImg+".m";
           vcl_ofstream ofstr(outName.c_str(),vcl_ios_out);
           hist.print_to_m(ofstr);
           
       }
          

       vcl_cout << "\n";
    }

 return 0;
}
