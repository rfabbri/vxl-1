//this is smw_world.cxx
#include "smw_world.h"

smw_world::smw_world(unsigned const& ni, unsigned const&nj)
{
    //create a world of graphs with a 1:1 pixel:graph
    //corespondence
    this->set_size(ni,nj);
}

smw_world::smw_world(vil_image_view<vxl_byte> const& img)
{
    this->set_size(img.ni(),img.nj());
    if(!this->update(img))
        vcl_cerr << "Error: smw_world constructor"
                 << " update unsuccessful." << vcl_flush;
}

bool smw_world::set_size(unsigned const& ni, unsigned const& nj)
{
    if(!world_.empty())
        world_.clear(); //erase all elements of the world
    ni_ = ni;
    nj_ = nj;
    vcl_vector<smw_graph> cols(ni_);
    vcl_cout << "in world.set_size(), cols.size() = " << cols.size() << vcl_endl;
    for(unsigned row = 0; row < nj_; ++row)
        world_.push_back(cols);
    return true;
}

bool smw_world::update(vil_image_view<vxl_byte> const& img)
{
    if((img.ni() == ni_) && 
       (img.nj() == nj_) )
    {
        unsigned n_cols = img.ni();
        unsigned n_rows = img.nj();
        for(unsigned row = 0; row < n_rows; ++row)
            for(unsigned col = 0; col < n_cols; ++col)
                world_[row][col].update(img(col,row,0));                
        return true;
    }
    else
    {
        vcl_cerr << "Error in updating world." << '\n'
                 << "Image size and world size not equal."
                 << vcl_flush;
        return false;
    }
}

vil_image_view<vxl_byte> smw_world::change_map()
{
    vil_image_view<vxl_byte> chg_map(ni_,nj_,1);
    for(unsigned ni = 0; ni < ni_; ++ni)
        for(unsigned nj = 0; nj < nj_; ++nj)
        {
            if(world_[ni][nj].change() == true)
                chg_map(ni,nj,0) = 255;
            else
                chg_map(ni,nj,0) = 0;
        }
    return chg_map;
}

//return the size of the world (recall ni = # columns and
//nj = # rows 
void smw_world::size(unsigned& ni, unsigned& nj)
{
    ni = world_[0].size();
    nj = world_.size();
}
