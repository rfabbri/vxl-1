// this is smw_graph.cxx
#include "smw_graph.h"
#include <vcl_cmath.h>//for abs fnc

void smw_graph::print_graph_params(unsigned const& node_id)
{
    vcl_cout << "Node " << node_id << '\n';
    vcl_cout << '\t' << "Mean: " << node_graph_[node_id].mean() << '\n';
    vcl_cout << '\t' << "Sigma: " << node_graph_[node_id].sigma() << vcl_endl;
}


void smw_graph::print_full_graph()
{
    unsigned length = node_graph_.size();
    for(unsigned i = 0; i < length; ++i)
        print_graph_params(i);
}

//necissary because we will load vil_image_view<vxl_byte>
bool smw_graph::update(const unsigned char & observation)
{
    float obs = static_cast<float>(observation);
    this->update(obs);
}

bool smw_graph::update(float const& observation)
{
    //case 1: the graph is empty
    if(node_graph_.empty())
    {
        //create a new node
        smw_node new_node; 
        if(!new_node.update(observation))
            vcl_cerr << "Error in smw_graph::update, empty node conditional" << vcl_flush;
        curr_node_id_ = 0;
        node_graph_.push_back(new_node);
        return 1;
    }
    else
    {
    //case 2: the graph is not empty
    //If the new observation is within 2 standard deviations of any 
    //current model, update the model who's mean is closest to the observation.
    //If the new observation is not within 2 standard deviations of any model,
    //create a new node.
        bool matching_node_found = false;
        float curr_mean = 0,curr_sig = 0;
        unsigned length = node_graph_.size();
        unsigned min_diff_indx;
        float min_diff,curr_diff;
        unsigned num_matches = 0;
        for(unsigned i = 0; i < length; ++i)
        {
            
            curr_mean = node_graph_[i].mean();
            curr_sig = node_graph_[i].sigma();
            float min_bound = curr_mean-(2*curr_sig);
            float max_bound = curr_mean+(2*curr_sig);
            if( (min_bound < observation) && (observation < max_bound) )
            {
                curr_diff = vcl_abs(curr_mean - observation);
                //if this is the first match found
                //or if the current difference is less than 
                //the minimum difference.
                if( (curr_diff < min_diff) ||
                    (matching_node_found == false) )    
                {
                    min_diff = curr_diff;
                    min_diff_indx = i;            
                }
               //will be true from the first matching
               //node on ward...
                matching_node_found = true;
             }          
        }
    
        if(matching_node_found == true)
        {
            //if a matching node was found, update the node with the 
            //minimum distance from the observation to the mean
            node_graph_[min_diff_indx].update(observation);
            curr_node_id_ = min_diff_indx;
            change_ = false;
        }
        else
        {
            //create a new node as no node best explains the observation
            smw_node new_node;
            if(!new_node.update(observation))
                vcl_cerr << "Error in smw_graph::update, no best explanation conditional" 
                         << vcl_flush;
            node_graph_.push_back(new_node);
            curr_node_id_ = node_graph_.size();
            change_ = true;
        }
        return 1;
    }
    vcl_cerr << "smw_graph.update(observation) failed" << vcl_flush;
    return 0;
}
