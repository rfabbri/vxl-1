#if !defined(SPLR_BASIC_PIZZA_SLICE_SPLAT_COLLECTION_TXX_)
#define SPLR_BASIC_PIZZA_SLICE_SPLAT_COLLECTION_TXX_

/* need to instantiate:
    - explicit_splat_collection
    - symmetry_splat_collection
    - subset_splat_collection
*/

#include "splr_basic_pizza_slice_splat_collection.h"
#include "splr_explicit_splat_collection.txx"
#include "splr_symmetry_splat_collection.txx"
#include "splr_subset_splat_collection.txx"
#include "splr_pizza_slice_symmetry_representatives.h"
#include "splr_symmetry_worldpt_roster.h"
#include <biob/biob_worldpt_roster_sptr.h>
#include <biob/biob_roster_to_grid_mapping.h>

template<class T, class F, class scan_class, class filter_2d_class, class filter_3d_class, class camera_class>
splr_basic_pizza_slice_splat_collection<T,F, scan_class, filter_2d_class, filter_3d_class, camera_class>::
   splr_basic_pizza_slice_splat_collection(scan_class scan, filter_3d_class * filter,
                                           biob_worldpt_box box, double spacing,
                                           unsigned start_index, unsigned period){
  //transformation taking camera of slice 0 to camera of slice 1
  vnl_quaternion<double> camera0_to_camera1 = dynamic_cast<xscan_uniform_orbit*>(scan.orbit().ptr())->rot().inverse();
  splr_symmetry * symmetry = new splr_pizza_slice_symmetry(camera0_to_camera1);
  unsigned int num_slices = symmetry->size();
  biob_explicit_worldpt_roster_sptr representatives = new biob_explicit_worldpt_roster();
  //select representatives based on the pizza_slice symmetry
  splr_pizza_slice_symmetry_representatives(representatives, num_slices, box, spacing);
  vcl_cout << "(splr_basic_pizza_slice_splat_collection.txx) number of representatives: " << representatives->num_points() << " \n";
  //create a roster generated by the representative points
  biob_worldpt_roster_sptr symmetry_roster = new splr_symmetry_worldpt_roster(symmetry, *(reinterpret_cast<biob_worldpt_roster_sptr*>(&representatives)));
  //create explicit splat collection for the representatives.
  explicit_splat_collection_ = new splr_explicit_splat_collection<T, F, scan_class, filter_2d_class, filter_3d_class, camera_class>(scan, num_slices, filter, *reinterpret_cast<biob_worldpt_roster_sptr*>(&representatives), start_index, period); 
  //create a splat collection based on the symmetry and the splat collection for the representatives
  symmetry_splat_collection_ = new splr_symmetry_splat_collection<T, filter_2d_class>(symmetry, explicit_splat_collection_,
                                                                                      representatives->num_points());

  //create a splat collection for a subset of the points represented by the symmetry roster
  subset_splat_collection_ = new splr_subset_splat_collection<T, filter_2d_class>(symmetry_splat_collection_, symmetry_roster);
  //populate subset with points near centerpoints of grid voxels
  biob_grid_worldpt_roster grid_roster(box, spacing);
  vcl_vector<biob_worldpt_index> mapping_from_grid_points_to_sample_pts;
  biob_roster_to_grid_mapping(symmetry_roster, grid_roster, mapping_from_grid_points_to_sample_pts);
  //in mapping_from_grid_grid_points_to_sample_pts, an entry whose index is more than symmetry_roster->num_points() indicates 
  //that the corresponding grid point has no corresponding symmetry_roster pt.
  assert(subset_splat_collection_->subset_roster()->which_points().size() == 0);
  for (unsigned int i = 0; i < mapping_from_grid_points_to_sample_pts.size(); ++i){
    if (mapping_from_grid_points_to_sample_pts[i].index() < symmetry_roster->num_points()){
      subset_splat_collection_->subset_roster()->which_points().push_back(mapping_from_grid_points_to_sample_pts[i]);
    }
  }
  vcl_cout << "\n(splr_basic_pizza_slice_splat_collection.txx) number of sample points: " << subset_splat_collection_->subset_roster()->num_points() << " \n";
  
  //create the rotation field
  rotation_field_.set_roster(roster());
  for (unsigned int i = 0; i < subset_splat_collection_->subset_roster()->num_points(); ++i){
    biob_worldpt_index pti_in_symmetry_roster =  subset_splat_collection_->subset_roster()->which_points()[i];
    unsigned int coset = pti_in_symmetry_roster.index() / representatives->num_points();
    vnl_quaternion<double> rotation_to_coset(camera0_to_camera1.axis(), coset * camera0_to_camera1.angle());
    rotation_field_.values()[i] = rotation_to_coset;
  }
}

template<class T, class F, class scan_class, class filter_2d_class, class filter_3d_class, class camera_class>
splr_subset_splat_collection<T, filter_2d_class> * splr_basic_pizza_slice_splat_collection<T,F, scan_class, filter_2d_class, filter_3d_class, camera_class>::collection(){
  return subset_splat_collection_;
}

template<class T, class F, class scan_class, class filter_2d_class, class filter_3d_class, class camera_class>
const biob_worldpt_field<vnl_quaternion<double> > &
splr_basic_pizza_slice_splat_collection<T,F, scan_class, filter_2d_class, filter_3d_class, camera_class>::rotation_field(){
  return rotation_field_;
}


#define SPLR_BASIC_PIZZA_SLICE_SPLAT_COLLECTION_INSTANTIATE(T, F) \
  template class splr_basic_pizza_slice_splat_collection<T, F>;   \
  SPLR_EXPLICIT_SPLAT_COLLECTION_INSTANTIATE(T, F) 

#define SPLR_BASIC_PIZZA_SLICE_SPLAT_COLLECTION_WITH_ALL_ARGS_INSTANTIATE(T, F, scan_class, filter_2d_class, filter_3d_class, camera_class) \
  template class splr_basic_pizza_slice_splat_collection<T, F, scan_class, filter_2d_class, filter_3d_class, camera_class>; \
  SPLR_EXPLICIT_SPLAT_COLLECTION_WITH_ALL_ARGS_INSTANTIATE(T, F, scan_class, filter_2d_class, filter_3d_class, camera_class) \
  SPLR_SYMMETRY_SPLAT_COLLECTION_WITH_ALL_ARGS_INSTANTIATE(T, filter_2d_class ) \
  SPLR_SUBSET_SPLAT_COLLECTION_WITH_ALL_ARGS_INSTANTIATE(T, filter_2d_class )

#endif
