// This is brcv/shp/dbskfg/dbskfg_compute_composite_graph.cxx

//:
// \file
#include <dbskfg/algo/dbskfg_extract_fragments.h>

#include <dbskfg/dbskfg_composite_graph.h>
#include <dbskfg/pro/dbskfg_composite_graph_storage_sptr.h>
#include <dbskfg/pro/dbskfg_composite_graph_storage.h>
#include <dbskfg/pro/dbskfg_form_composite_graph_process.h>
#include <dbskfg/algo/dbskfg_detect_transforms.h>
#include <dbskfg/algo/dbskfg_composite_graph_fileio.h>

#include <dbsk2d/pro/dbsk2d_shock_storage.h>
#include <dbsk2d/pro/dbsk2d_compute_ishock_process.h>


dbskfg_extract_fragments::dbskfg_extract_fragments
( 
    vidpro1_vsol2D_storage_sptr input_vsol,
    vidpro1_image_storage_sptr image_storage
)
{
    compute_first_graph(input_vsol,image_storage);
}

dbskfg_extract_fragments::~dbskfg_extract_fragments()
{
}

void dbskfg_extract_fragments::compute_first_graph(
    vidpro1_vsol2D_storage_sptr& input_vsol,
    vidpro1_image_storage_sptr& image_storage)
{

    /*********************** Shock Compute **********************************/
    // 1) Create shock pro process and assign inputs 
    dbsk2d_compute_ishock_process shock_pro;

    shock_pro.clear_input();
    shock_pro.clear_output();

    shock_pro.add_input(image_storage);
    shock_pro.add_input(input_vsol);

    bool ishock_status = shock_pro.execute();
    shock_pro.finish();

    assert(ishock_status == true);

    // Grab output from shock computation
    vcl_vector<bpro1_storage_sptr> shock_results;

    shock_results = shock_pro.get_output();

    // Clean up after ourselves
    shock_pro.clear_input();
    shock_pro.clear_output();

    // Lets vertical cast to shock stroge
    dbsk2d_shock_storage_sptr shock_storage;
    shock_storage.vertical_cast(shock_results[0]);

    /*********************** Compute Composite Graph ************************/
    dbskfg_form_composite_graph_process cg_pro;

    cg_pro.clear_input();
    cg_pro.clear_output();

    cg_pro.add_input(shock_storage);
    cg_pro.add_input(image_storage);

    bool status = cg_pro.execute();
    cg_pro.finish();

    vcl_vector<bpro1_storage_sptr> cg_results;
    cg_results = cg_pro.get_output();

    cg_pro.clear_input();
    cg_pro.clear_output();

    dbskfg_composite_graph_storage_sptr cg_storage;
    cg_storage.vertical_cast(cg_results[0]);

    composite_graph_ = cg_storage->get_composite_graph();
    rag_graph_       = cg_storage->get_rag_graph();
    image_           = cg_storage->get_image();
}

void dbskfg_extract_fragments::extract(
    bool detect_gaps,
    bool detect_loops,
    double ess_completion,
    double alpha,
    double transform_thresh,
    double contour_ratio,
    double prune_thres,
    vcl_string output_folder,
    vcl_string output_prefix)
{

    // First lets detect transforms
    dbskfg_detect_transforms transforms(composite_graph_,image_);

    // First lets do a small set of gaps then loops
    // Keep doing gaps
    transforms.detect_transforms(true,
                                 false,
                                 ess_completion,
                                 0.4);

    unsigned int iterations=1;
    while ( transforms.transforms_valid(transform_thresh) > 0 )
    {
        // Apply then destroy
        unsigned int n = transforms.apply_transforms(0.5,rag_graph_);
        transforms.destroy_transforms();

        vcl_cout<<"Iteration: "<<iterations<<vcl_endl;
        iterations++;
        
        if ( n == 0 )
        {
            break;
        }
        
        // Detect a new set of transforms
        transforms.detect_transforms(true,
                                     false,
                                     ess_completion,
                                     0.4);
        
      
    }

    //First lets do a small set of gaps then loops
    //Keep doing gaps
    transforms.detect_transforms(false,
                                 true,
                                 ess_completion,
                                 1);

    iterations=1;
    while ( transforms.transforms_valid(transform_thresh) > 0 )
    {
        // Apply then destroy
        unsigned int n = transforms.apply_transforms(0.1,rag_graph_);
        transforms.destroy_transforms();

        vcl_cout<<"Iteration: "<<iterations<<vcl_endl;
        iterations++;
        
        if ( n == 0 )
        {
            break;
        }
        
        // Detect a new set of transforms
        transforms.detect_transforms(false,
                                     true,
                                     ess_completion,
                                     1);
        
      
    }

    // write out fragments
    dbskfg_composite_graph_fileio file;
    file.write_out(rag_graph_,image_,
                   output_prefix,
                   output_folder,
                   contour_ratio,
                   prune_thres);


}
