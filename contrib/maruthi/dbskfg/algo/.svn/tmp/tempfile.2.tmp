// This is brcv/shp/dbskfg/dbskfg_compute_composite_graph.cxx

//:
// \file
#include <dbskfg/algo/dbskfg_extract_fragments.h>

#include <dbskfg/dbskfg_composite_graph.h>
#include <dbskfg/dbskfg_rag_graph.h>
#include <dbskfg/pro/dbskfg_composite_graph_storage_sptr.h>
#include <dbskfg/pro/dbskfg_composite_graph_storage.h>
#include <dbskfg/pro/dbskfg_form_composite_graph_process.h>
#include <dbskfg/algo/dbskfg_detect_transforms.h>
#include <dbskfg/algo/dbskfg_composite_graph_fileio.h>

#include <dbsk2d/pro/dbsk2d_shock_storage.h>
#include <dbsk2d/pro/dbsk2d_compute_ishock_process.h>

#include <vil/vil_image_resource.h>
#include <vgl/vgl_area.h>

#include <vidpro1/storage/vidpro1_image_storage.h>

dbskfg_extract_fragments::dbskfg_extract_fragments() 
{
}

dbskfg_extract_fragments::~dbskfg_extract_fragments()
{
}

void dbskfg_extract_fragments::compute_first_graph(
    vidpro1_vsol2D_storage_sptr& input_vsol,
    vidpro1_image_storage_sptr& image_storage)
{

    /*********************** Shock Compute **********************************/
    // 1) Create shock pro process and assign inputs 
    dbsk2d_compute_ishock_process shock_pro;

    shock_pro.clear_input();
    shock_pro.clear_output();

    shock_pro.add_input(image_storage);
    shock_pro.add_input(input_vsol);

    bool ishock_status = shock_pro.execute();
    shock_pro.finish();

    assert(ishock_status == true);

    // Grab output from shock computation
    vcl_vector<bpro1_storage_sptr> shock_results;

    shock_results = shock_pro.get_output();

    // Clean up after ourselves
    shock_pro.clear_input();
    shock_pro.clear_output();

    // Lets vertical cast to shock stroge
    dbsk2d_shock_storage_sptr shock_storage;
    shock_storage.vertical_cast(shock_results[0]);

    /*********************** Compute Composite Graph ************************/
    dbskfg_form_composite_graph_process cg_pro;

    cg_pro.clear_input();
    cg_pro.clear_output();

    cg_pro.add_input(shock_storage);
    cg_pro.add_input(image_storage);

    bool status = cg_pro.execute();
    cg_pro.finish();

    vcl_vector<bpro1_storage_sptr> cg_results;
    cg_results = cg_pro.get_output();

    cg_pro.clear_input();
    cg_pro.clear_output();

    dbskfg_composite_graph_storage_sptr cg_storage;
    cg_storage.vertical_cast(cg_results[0]);

    composite_graph_ = cg_storage->get_composite_graph();
    rag_graph_       = cg_storage->get_rag_graph();
   

}

void dbskfg_extract_fragments::determine_start_regions(double contour_ratio)
{
    
    // sort nodes by contour_ratio
    vcl_vector<dbskfg_rag_node_sptr> rag_nodes_by_contour;

    // push back node 
    for (dbskfg_rag_graph::vertex_iterator vit = 
             rag_graph_->vertices_begin(); 
         vit != rag_graph_->vertices_end(); ++vit)
    {
        dbskfg_rag_node_sptr rag_node = *vit;
        if ((*vit)->is_rag_node_within_image(image_->ni(),image_->nj()))
        {
            if ( rag_node->contour_ratio() >= contour_ratio )
            {
                rag_nodes_by_contour.push_back(rag_node);
            }
        }
    }

    // Loop thru all rag nodes and sort by area
    for ( unsigned int i=0 ; i < rag_nodes_by_contour.size() ; ++i)
    {
        vgl_polygon<double> poly;
        rag_nodes_by_contour[i]->fragment_boundary(poly);
        double area = vgl_area(poly);
        start_rag_nodes_[area]=rag_nodes_by_contour[i]->id();
    }

    
}

void dbskfg_extract_fragments::extract(
    vidpro1_vsol2D_storage_sptr& input_vsol,
    vidpro1_image_storage_sptr& image_storage,
    bool detect_gaps,
    bool detect_loops,
    double ess_completion,
    double alpha,
    double transform_thresh,
    double contour_ratio,
    double prune_thres,
    vcl_string output_folder,
    vcl_string output_prefix)
{

    image_ = image_storage->get_image();

    // Compute first graph first
    compute_first_graph(input_vsol,image_storage);

    // Determine start regions to consider
    determine_start_regions(contour_ratio);
    
    unsigned int frag_limit=0;

    vcl_map<double,unsigned int>::reverse_iterator it;
    for ( it = start_rag_nodes_.rbegin() ; it != start_rag_nodes_.rend() ; ++it)
    {
        frag_limit++;
        vcl_cout<<"Fragment id: "<<(*it).second<<" Area: "<<(*it).first<<
            vcl_endl;
        
        dbskfg_rag_node_sptr rag_node = rag_graph_->rag_node((*it).second);

        // Apply Transforms to this region
        extract_helper(rag_node,
                       detect_gaps,
                       detect_loops,
                       ess_completion,
                       alpha,
                       transform_thresh,
                       contour_ratio,
                       prune_thres,
                       output_folder,
                       output_prefix);

        
        if ( frag_limit == 20 )
        {
             break;
        }

        composite_graph_->clear();
        rag_graph_->clear();

        // Recompute the graph
        compute_first_graph(input_vsol,image_storage);


    }

}



void dbskfg_extract_fragments::extract_helper(dbskfg_rag_node_sptr start_region,
                                              bool detect_gaps,
                                              bool detect_loops,
                                              double ess_completion,
                                              double alpha,
                                              double transform_thresh,
                                              double contour_ratio,
                                              double prune_thres,
                                              vcl_string output_folder,
                                              vcl_string output_prefix
)
{

    // First lets detect transforms
    dbskfg_detect_transforms transforms(composite_graph_,image_);
    transforms.set_rag_node(start_region);

    // Keep a shock link that represents this rag node
    vcl_map<unsigned int,dbskfg_shock_link*> shock_links
        = start_region->get_shock_links();
    dbskfg_shock_link* shock_link = (*shock_links.begin()).second;

    // Keep track of the id
    unsigned int region_id = start_region->id();

    vcl_cout<<"Starting growing from rag node id: "<<
        region_id<<vcl_endl;

    unsigned int iterations=1;

    // Detect transforms
    transforms.detect_transforms(detect_gaps,
                                 detect_loops,
                                 ess_completion,
                                 alpha);
    bool status_flag=true;

    while ( transforms.transforms_valid(transform_thresh) > 0 )
    {
        // Apply then destroy
        unsigned int n = 
            transforms.apply_transforms(transform_thresh,rag_graph_);
        transforms.destroy_transforms();
        
        vcl_cout<<"Iteration: "<<iterations<<vcl_endl;
        
        if ( n == 0 )
        {
            break;
        }

        iterations++;
      
        dbskfg_rag_node_sptr next_rag_node = 
            rag_graph_->rag_node(region_id);

        if ( next_rag_node == 0 )
        {
            if ( shock_link )
            {
                
                next_rag_node = shock_link->get_rag_node();
                if ( next_rag_node == 0 )
                {
                    status_flag=false;
                    break;
                }
                
            }
            else
            {
                status_flag=false;
                break;
            }
        }

        region_id=next_rag_node->id();
        transforms.set_rag_node(next_rag_node);

        
        vcl_cout<<"next rag node: "<<region_id<<vcl_endl;

        
        // Detect a new set of transforms
        transforms.detect_transforms(detect_gaps,
                                     detect_loops,
                                     ess_completion,
                                     alpha);
        
        
     
    }

    if ( status_flag )
    {
        // write out fragments
        dbskfg_composite_graph_fileio file;
        file.write_out(rag_graph_,
                       image_,
                       region_id,
                       prune_thres,
                       output_prefix,
                       output_folder);
    }
}
